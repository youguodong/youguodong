<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Vuex 状态管理的工作原理]]></title>
    <url>%2F2018%2F10%2F25%2FVuex%20%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[Vuex 状态管理的工作原理为什么要使用 Vuex当我们使用 Vue.js 来开发一个单页应用时，经常会遇到一些组件间共享的数据或状态，或是需要通过 props 深层传递的一些数据。在应用规模较小的时候，我们会使用 props、事件等常用的父子组件的组件间通信方法，或者是通过事件总线来进行任意两个组件的通信。但是当应用逐渐复杂后，问题就开始出现了，这样的通信方式会导致数据流异常地混乱。 这个时候，我们就需要用到我们的状态管理工具 Vuex 了。Vuex 是一个专门为 Vue.js 框架设计的、专门用来对于 Vue.js 应用进行状态管理的库。它借鉴了 Flux、redux 的基本思想，将状态抽离到全局，形成一个 Store。因为 Vuex 内部采用了 new Vue 来将 Store 内的数据进行「响应式化」，所以 Vuex 是一款利用 Vue 内部机制的库，与 Vue 高度契合，与 Vue 搭配使用显得更加简单高效，但缺点是不能与其他的框架（如 react）配合使用。 本节将简单介绍 Vuex 最核心的内部机制，起个抛砖引玉的作用，想了解更多细节可以参考笔者 Github 上的另一篇文章 《Vuex源码解析》或者直接阅读 Vuex源码。 安装Vue.js 提供了一个 Vue.use 的方法来安装插件，内部会调用插件提供的 install 方法。 1Vue.use(Vuex); 所以我们的插件需要提供一个 install 方法来安装。 123456let Vue;export default install (_Vue) &#123; Vue.mixin(&#123; beforeCreate: vuexInit &#125;); Vue = _Vue;&#125; 我们采用 Vue.mixin 方法将 vuexInit 方法混淆进 beforeCreate 钩子中，并用 Vue 保存 Vue 对象。那么 vuexInit 究竟实现了什么呢？ 我们知道，在使用 Vuex 的时候，我们需要将 store 传入到 Vue 实例中去。 12345/*将store放入Vue创建时的option中*/new Vue(&#123; el: &apos;#app&apos;, store&#125;); 但是我们却在每一个 vm 中都可以访问该 store，这个就需要靠 vuexInit 了。 12345678function vuexInit () &#123; const options = this.$options; if (options.store) &#123; this.$store = options.store; &#125; else &#123; this.$store = options.parent.$store; &#125;&#125; 因为之前已经用Vue.mixin 方法将 vuexInit 方法混淆进 beforeCreate 钩子中，所以每一个 vm 实例都会调用 vuexInit 方法。 如果是根节点（$options中存在 store 说明是根节点），则直接将 options.store 赋值给 this.$store。否则则说明不是根节点，从父节点的 $store 中获取。 通过这步的操作，我们已经可以在任意一个 vm 中通过 this.$store 来访问 Store 的实例啦～ Store数据的响应式化首先我们需要在 Store 的构造函数中对 state 进行「响应式化」。 1234567constructor () &#123; this._vm = new Vue(&#123; data: &#123; $$state: this.state &#125; &#125;)&#125; 熟悉「响应式」的同学肯定知道，这个步骤以后，state 会将需要的依赖收集在 Dep 中，在被修改时更新对应视图。我们来看一个小例子。 12345678910111213141516171819let globalData = &#123; d: &apos;hello world&apos;&#125;;new Vue(&#123; data () &#123; return &#123; $$state: &#123; globalData &#125; &#125; &#125;&#125;);/* modify */setTimeout(() =&gt; &#123; globalData.d = &apos;hi~&apos;;&#125;, 1000);Vue.prototype.globalData = globalData; 任意模板中 1&lt;div&gt;&#123;&#123;globalData.d&#125;&#125;&lt;/div&gt; 上述代码在全局有一个 globalData，它被传入一个 Vue 对象的 data 中，之后在任意 Vue 模板中对该变量进行展示，因为此时 globalData 已经在 Vue 的 prototype 上了所以直接通过 this.prototype 访问，也就是在模板中的 。此时，setTimeout 在 1s 之后将 globalData.d 进行修改，我们发现模板中的 globalData.d 发生了变化。其实上述部分就是 Vuex 依赖 Vue 核心实现数据的“响应式化”。 讲完了 Vuex 最核心的通过 Vue 进行数据的「响应式化」，接下来我们再来介绍两个 Store 的 API。 commit首先是 commit 方法，我们知道 commit 方法是用来触发 mutation 的。 123456commit (type, payload, _options) &#123; const entry = this._mutations[type]; entry.forEach(function commitIterator (handler) &#123; handler(payload); &#125;);&#125; 从 _mutations 中取出对应的 mutation，循环执行其中的每一个 mutation。 dispatchdispatch 同样道理，用于触发 action，可以包含异步状态。 1234567dispatch (type, payload) &#123; const entry = this._actions[type]; return entry.length &gt; 1 ? Promise.all(entry.map(handler =&gt; handler(payload))) : entry[0](payload);&#125; 同样的，取出 _actions 中的所有对应 action，将其执行，如果有多个则用 Promise.all 进行包装。 最后理解 Vuex 的核心在于理解其如何与 Vue 本身结合，如何利用 Vue 的响应式机制来实现核心 Store 的「响应式化」。 Vuex 本身代码不多且设计优雅，非常值得一读，想阅读源码的同学请看Vuex源码。 注：本节代码参考《Vuex状态管理的工作原理》。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue.js 运行机制全局概览]]></title>
    <url>%2F2018%2F10%2F14%2FVue.js%20%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6%E5%85%A8%E5%B1%80%E6%A6%82%E8%A7%88%2F</url>
    <content type="text"><![CDATA[全局概览这一节笔者将为大家介绍一下 Vue.js 内部的整个流程，希望能让大家对全局有一个整体的印象，然后我们再来逐个模块进行讲解。从来没有了解过 Vue.js 实现的同学可能会对一些内容感到疑惑，这是很正常的，这一节的目的主要是为了让大家对整个流程有一个大概的认识，算是一个概览预备的过程，当把整本小册认真读完以后，再来阅读这一节，相信会有收获的。 首先我们来看一下笔者画的内部流程图。 大家第一次看到这个图一定是一头雾水的，没有关系，我们来逐个讲一下这些模块的作用以及调用关系。相信讲完之后大家对Vue.js内部运行机制会有一个大概的认识。 初始化及挂载 在 new Vue() 之后。 Vue 会调用 _init 函数进行初始化，也就是这里的 init 过程，它会初始化生命周期、事件、 props、 methods、 data、 computed 与 watch 等。其中最重要的是通过 Object.defineProperty 设置 setter 与 getter 函数，用来实现「响应式」以及「依赖收集」，后面会详细讲到，这里只要有一个印象即可。 初始化之后调用 $mount 会挂载组件，如果是运行时编译，即不存在 render function 但是存在 template 的情况，需要进行「编译」步骤。 编译compile编译可以分成 parse、optimize 与 generate 三个阶段，最终需要得到 render function。 parseparse 会用正则等方式解析 template 模板中的指令、class、style等数据，形成AST。 optimizeoptimize 的主要作用是标记 static 静态节点，这是 Vue 在编译过程中的一处优化，后面当 update 更新界面时，会有一个 patch 的过程， diff 算法会直接跳过静态节点，从而减少了比较的过程，优化了 patch 的性能。 generategenerate 是将 AST 转化成 render function 字符串的过程，得到结果是 render 的字符串以及 staticRenderFns 字符串。 在经历过 parse、optimize 与 generate 这三个阶段以后，组件中就会存在渲染 VNode 所需的 render function 了。 响应式接下来也就是 Vue.js 响应式核心部分。 这里的 getter 跟 setter 已经在之前介绍过了，在 init 的时候通过 Object.defineProperty 进行了绑定，它使得当被设置的对象被读取的时候会执行 getter 函数，而在当被赋值的时候会执行 setter 函数。 当 render function 被渲染的时候，因为会读取所需对象的值，所以会触发 getter 函数进行「依赖收集」，「依赖收集」的目的是将观察者 Watcher 对象存放到当前闭包中的订阅者 Dep 的 subs 中。形成如下所示的这样一个关系。 在修改对象的值的时候，会触发对应的 setter， setter 通知之前「依赖收集」得到的 Dep 中的每一个 Watcher，告诉它们自己的值改变了，需要重新渲染视图。这时候这些 Watcher 就会开始调用 update 来更新视图，当然这中间还有一个 patch 的过程以及使用队列来异步更新的策略，这个我们后面再讲。 Virtual DOM我们知道，render function 会被转化成 VNode 节点。Virtual DOM 其实就是一棵以 JavaScript 对象（ VNode 节点）作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。 比如说下面这样一个例子： 123456789&#123; tag: &apos;div&apos;, /*说明这是一个div标签*/ children: [ /*存放该标签的子节点*/ &#123; tag: &apos;a&apos;, /*说明这是一个a标签*/ text: &apos;click me&apos; /*标签的内容*/ &#125; ]&#125; 渲染后可以得到 123&lt;div&gt; &lt;a&gt;click me&lt;/a&gt;&lt;/div&gt; 这只是一个简单的例子，实际上的节点有更多的属性来标志节点，比如 isStatic （代表是否为静态节点）、 isComment （代表是否为注释节点）等。 更新视图 前面我们说到，在修改一个对象值的时候，会通过 setter -&gt; Watcher -&gt; update 的流程来修改对应的视图，那么最终是如何更新视图的呢？ 当数据变化后，执行 render function 就可以得到一个新的 VNode 节点，我们如果想要得到新的视图，最简单粗暴的方法就是直接解析这个新的 VNode 节点，然后用 innerHTML 直接全部渲染到真实 DOM 中。但是其实我们只对其中的一小块内容进行了修改，这样做似乎有些「浪费」。 那么我们为什么不能只修改那些「改变了的地方」呢？这个时候就要介绍我们的「patch」了。我们会将新的 VNode 与旧的 VNode 一起传入 patch 进行比较，经过 diff 算法得出它们的「差异」。最后我们只需要将这些「差异」的对应 DOM 进行修改即可。 再看全局 回过头再来看看这张图，是不是大脑中已经有一个大概的脉络了呢？ 那么，让我们继续学习每一个模块吧!]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[template 模板是怎样通过 Compile 编译的]]></title>
    <url>%2F2018%2F10%2F11%2Ftemplate%20%E6%A8%A1%E6%9D%BF%E6%98%AF%E6%80%8E%E6%A0%B7%E9%80%9A%E8%BF%87%20Compile%20%E7%BC%96%E8%AF%91%E7%9A%84%2F</url>
    <content type="text"><![CDATA[Compilecompile 编译可以分成 parse、optimize 与 generate 三个阶段，最终需要得到 render function。这部分内容不算 Vue.js 的响应式核心，只是用来编译的，笔者认为在精力有限的情况下不需要追究其全部的实现细节，能够把握如何解析的大致流程即可。 由于解析过程比较复杂，直接上代码可能会导致不了解这部分内容的同学一头雾水。所以笔者准备提供一个 template 的示例，通过这个示例的变化来看解析的过程。但是解析的过程及结果都是将最重要的部分抽离出来展示，希望能让读者更好地了解其核心部分的实现。 123&lt;div :class=&quot;c&quot; class=&quot;demo&quot; v-if=&quot;isShow&quot;&gt; &lt;span v-for=&quot;item in sz&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;&lt;/div&gt; 1var html = &apos;&lt;div :class=&quot;c&quot; class=&quot;demo&quot; v-if=&quot;isShow&quot;&gt;&lt;span v-for=&quot;item in sz&quot;&gt;&#123;&#123;item&#125;&#125;&lt;/span&gt;&lt;/div&gt;&apos;; 接下来的过程都会依赖这个示例来进行。 parse首先是 parse，parse 会用正则等方式将 template 模板中进行字符串解析，得到指令、class、style等数据，形成 AST（在计算机科学中，抽象语法树（abstract syntax tree或者缩写为AST），或者语法树（syntax tree），是源代码的抽象语法结构的树状表现形式，这里特指编程语言的源代码。）。 这个过程比较复杂，会涉及到比较多的正则进行字符串解析，我们来看一下得到的 AST 的样子。 1234567891011121314151617181920212223242526272829303132333435363738394041424344&#123; /* 标签属性的map，记录了标签上属性 */ &apos;attrsMap&apos;: &#123; &apos;:class&apos;: &apos;c&apos;, &apos;class&apos;: &apos;demo&apos;, &apos;v-if&apos;: &apos;isShow&apos; &#125;, /* 解析得到的:class */ &apos;classBinding&apos;: &apos;c&apos;, /* 标签属性v-if */ &apos;if&apos;: &apos;isShow&apos;, /* v-if的条件 */ &apos;ifConditions&apos;: [ &#123; &apos;exp&apos;: &apos;isShow&apos; &#125; ], /* 标签属性class */ &apos;staticClass&apos;: &apos;demo&apos;, /* 标签的tag */ &apos;tag&apos;: &apos;div&apos;, /* 子标签数组 */ &apos;children&apos;: [ &#123; &apos;attrsMap&apos;: &#123; &apos;v-for&apos;: &quot;item in sz&quot; &#125;, /* for循环的参数 */ &apos;alias&apos;: &quot;item&quot;, /* for循环的对象 */ &apos;for&apos;: &apos;sz&apos;, /* for循环是否已经被处理的标记位 */ &apos;forProcessed&apos;: true, &apos;tag&apos;: &apos;span&apos;, &apos;children&apos;: [ &#123; /* 表达式，_s是一个转字符串的函数 */ &apos;expression&apos;: &apos;_s(item)&apos;, &apos;text&apos;: &apos;&#123;&#123;item&#125;&#125;&apos; &#125; ] &#125; ]&#125; 最终得到的 AST 通过一些特定的属性，能够比较清晰地描述出标签的属性以及依赖关系。 接下来我们用代码来讲解一下如何使用正则来把 template 编译成我们需要的 AST 的。 正则首先我们定义一下接下来我们会用到的正则。 1234567891011121314151617181920212223const ncname = &apos;[a-zA-Z_][\\w\\-\\.]*&apos;;const singleAttrIdentifier = /([^\s&quot;&apos;&lt;&gt;/=]+)/const singleAttrAssign = /(?:=)/const singleAttrValues = [ /&quot;([^&quot;]*)&quot;+/.source, /&apos;([^&apos;]*)&apos;+/.source, /([^\s&quot;&apos;=&lt;&gt;`]+)/.source]const attribute = new RegExp( &apos;^\\s*&apos; + singleAttrIdentifier.source + &apos;(?:\\s*(&apos; + singleAttrAssign.source + &apos;)&apos; + &apos;\\s*(?:&apos; + singleAttrValues.join(&apos;|&apos;) + &apos;))?&apos;)const qnameCapture = &apos;((?:&apos; + ncname + &apos;\\:)?&apos; + ncname + &apos;)&apos;const startTagOpen = new RegExp(&apos;^&lt;&apos; + qnameCapture)const startTagClose = /^\s*(\/?)&gt;/const endTag = new RegExp(&apos;^&lt;\\/&apos; + qnameCapture + &apos;[^&gt;]*&gt;&apos;)const defaultTagRE = /\&#123;\&#123;((?:.|\n)+?)\&#125;\&#125;/gconst forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/ advance因为我们解析 template 采用循环进行字符串匹配的方式，所以每匹配解析完一段我们需要将已经匹配掉的去掉，头部的指针指向接下来需要匹配的部分。 1234function advance (n) &#123; index += n html = html.substring(n)&#125; 举个例子，当我们把第一个 div 的头标签全部匹配完毕以后，我们需要将这部分除去，也就是向右移动 43 个字符。 调用 advance 函数 1advance(43); 得到结果 parseHTML首先我们需要定义个 parseHTML 函数，在里面我们循环解析 template 字符串。 123456789101112131415161718function parseHTML () &#123; while(html) &#123; let textEnd = html.indexOf(&apos;&lt;&apos;); if (textEnd === 0) &#123; if (html.match(endTag)) &#123; //...process end tag continue; &#125; if (html.match(startTagOpen)) &#123; //...process start tag continue; &#125; &#125; else &#123; //...process text continue; &#125; &#125;&#125; parseHTML 会用 while 来循环解析 template ，用正则在匹配到标签头、标签尾以及文本的时候分别进行不同的处理。直到整个 template 被解析完毕。 parseStartTag我们来写一个 parseStartTag 函数，用来解析起始标签（”“部分的内容）。 1234567891011121314151617181920212223242526function parseStartTag () &#123; const start = html.match(startTagOpen); if (start) &#123; const match = &#123; tagName: start[1], attrs: [], start: index &#125; advance(start[0].length); let end, attr while (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(attribute))) &#123; advance(attr[0].length) match.attrs.push(&#123; name: attr[1], value: attr[3] &#125;); &#125; if (end) &#123; match.unarySlash = end[1]; advance(end[0].length); match.end = index; return match &#125; &#125;&#125; 首先用 startTagOpen 正则得到标签的头部，可以得到 tagName（标签名称），同时我们需要一个数组 attrs 用来存放标签内的属性。 1234567const start = html.match(startTagOpen);const match = &#123; tagName: start[1], attrs: [], start: index&#125;advance(start[0].length); 接下来使用 startTagClose 与 attribute 两个正则分别用来解析标签结束以及标签内的属性。这段代码用 while 循环一直到匹配到 startTagClose 为止，解析内部所有的属性。 1234567891011121314let end, attrwhile (!(end = html.match(startTagClose)) &amp;&amp; (attr = html.match(attribute))) &#123; advance(attr[0].length) match.attrs.push(&#123; name: attr[1], value: attr[3] &#125;);&#125;if (end) &#123; match.unarySlash = end[1]; advance(end[0].length); match.end = index; return match&#125; stack此外，我们需要维护一个 stack 栈来保存已经解析好的标签头，这样我们可以根据在解析尾部标签的时候得到所属的层级关系以及父标签。同时我们定义一个 currentParent 变量用来存放当前标签的父标签节点的引用， root 变量用来指向根标签节点。 12const stack = [];let currentParent, root; 知道这个以后，我们优化一下 parseHTML ，在 startTagOpen 的 if 逻辑中加上新的处理。 123456789101112131415161718192021222324if (html.match(startTagOpen)) &#123; const startTagMatch = parseStartTag(); const element = &#123; type: 1, tag: startTagMatch.tagName, lowerCasedTag: startTagMatch.tagName.toLowerCase(), attrsList: startTagMatch.attrs, attrsMap: makeAttrsMap(startTagMatch.attrs), parent: currentParent, children: [] &#125; if(!root)&#123; root = element &#125; if(currentParent)&#123; currentParent.children.push(element); &#125; stack.push(element); currentParent = element; continue;&#125; 我们将 startTagMatch 得到的结果首先封装成 element ，这个就是最终形成的 AST 的节点，标签节点的 type 为 1。 123456789const startTagMatch = parseStartTag();const element = &#123; type: 1, tag: startTagMatch.tagName, attrsList: startTagMatch.attrs, attrsMap: makeAttrsMap(startTagMatch.attrs), parent: currentParent, children: []&#125; 然后让 root 指向根节点的引用。 123if(!root)&#123; root = element&#125; 接着我们将当前节点的 element 放入父节点 currentParent 的 children 数组中。 123if(currentParent)&#123; currentParent.children.push(element);&#125; 最后将当前节点 element 压入 stack 栈中，并将 currentParent 指向当前节点，因为接下去下一个解析如果还是头标签或者是文本的话，会成为当前节点的子节点，如果是尾标签的话，那么将会从栈中取出当前节点，这种情况我们接下来要讲。 123stack.push(element);currentParent = element;continue; 其中的 makeAttrsMap 是将 attrs 转换成 map 格式的一个方法。 1234567function makeAttrsMap (attrs) &#123; const map = &#123;&#125; for (let i = 0, l = attrs.length; i &lt; l; i++) &#123; map[attrs[i].name] = attrs[i].value; &#125; return map&#125; parseEndTag同样，我们在 parseHTML 中加入对尾标签的解析函数，为了匹配如“”。 123456const endTagMatch = html.match(endTag) if (endTagMatch) &#123; advance(endTagMatch[0].length); parseEndTag(endTagMatch[1]); continue;&#125; 用 parseEndTag 来解析尾标签，它会从 stack 栈中取出最近的跟自己标签名一致的那个元素，将 currentParent 指向那个元素，并将该元素之前的元素都从 stack 中出栈。 这里可能有同学会问，难道解析的尾元素不应该对应 stack 栈的最上面的一个元素才对吗？ 其实不然，比如说可能会存在自闭合的标签，如“”，或者是写了“”但是没有加上“&lt; /span&gt;”的情况，这时候就要找到 stack 中的第二个位置才能找到同名标签。 12345678910111213function parseEndTag (tagName) &#123; let pos; for (pos = stack.length - 1; pos &gt;= 0; pos--) &#123; if (stack[pos].lowerCasedTag === tagName.toLowerCase()) &#123; break; &#125; &#125; if (pos &gt;= 0) &#123; stack.length = pos; currentParent = stack[pos]; &#125; &#125; parseText最后是解析文本，这个比较简单，只需要将文本取出，然后有两种情况，一种是普通的文本，直接构建一个节点 push 进当前 currentParent 的 children 中即可。还有一种情况是文本是如“”这样的 Vue.js 的表达式，这时候我们需要用 parseText 来将表达式转化成代码。 12345678910111213141516text = html.substring(0, textEnd)advance(textEnd)let expression;if (expression = parseText(text)) &#123; currentParent.children.push(&#123; type: 2, text, expression &#125;);&#125; else &#123; currentParent.children.push(&#123; type: 3, text, &#125;);&#125;continue; 我们会用到一个 parseText 函数。 1234567891011121314151617181920212223function parseText (text) &#123; if (!defaultTagRE.test(text)) return; const tokens = []; let lastIndex = defaultTagRE.lastIndex = 0 let match, index while ((match = defaultTagRE.exec(text))) &#123; index = match.index if (index &gt; lastIndex) &#123; tokens.push(JSON.stringify(text.slice(lastIndex, index))) &#125; const exp = match[1].trim() tokens.push(`_s($&#123;exp&#125;)`) lastIndex = index + match[0].length &#125; if (lastIndex &lt; text.length) &#123; tokens.push(JSON.stringify(text.slice(lastIndex))) &#125; return tokens.join(&apos;+&apos;);&#125; 我们使用一个 tokens 数组来存放解析结果，通过 defaultTagRE 来循环匹配该文本，如果是普通文本直接 push 到 tokens 数组中去，如果是表达式（），则转化成“_s(${exp})”的形式。 举个例子，如果我们有这样一个文本。 1&lt;div&gt;hello,&#123;&#123;name&#125;&#125;.&lt;/div&gt; 最终得到 tokens。 1tokens = [&apos;hello,&apos;, _s(name), &apos;.&apos;]; 最终通过 join 返回表达式。 1&apos;hello&apos; + _s(name) + &apos;.&apos;; processIf与processFor最后介绍一下如何处理“v-if”以及“v-for”这样的 Vue.js 的表达式的，这里我们只简单介绍两个示例中用到的表达式解析。 我们只需要在解析头标签的内容中加入这两个表达式的解析函数即可，在这时“v-for”之类指令已经在属性解析时存入了 attrsMap 中了。 1234567891011121314151617181920212223242526if (html.match(startTagOpen)) &#123; const startTagMatch = parseStartTag(); const element = &#123; type: 1, tag: startTagMatch.tagName, attrsList: startTagMatch.attrs, attrsMap: makeAttrsMap(startTagMatch.attrs), parent: currentParent, children: [] &#125; processIf(element); processFor(element); if(!root)&#123; root = element &#125; if(currentParent)&#123; currentParent.children.push(element); &#125; stack.push(element); currentParent = element; continue;&#125; 首先我们需要定义一个 getAndRemoveAttr 函数，用来从 el 的 attrsMap 属性或是 attrsList 属性中取出 name 对应值。 12345678910111213function getAndRemoveAttr (el, name) &#123; let val if ((val = el.attrsMap[name]) != null) &#123; const list = el.attrsList for (let i = 0, l = list.length; i &lt; l; i++) &#123; if (list[i].name === name) &#123; list.splice(i, 1) break &#125; &#125; &#125; return val&#125; 比如说解析示例的 div 标签属性。 1getAndRemoveAttr(el, &apos;v-for&apos;); 可有得到“item in sz”。 有了这个函数这样我们就可以开始实现 processFor 与 processIf 了。 “v-for”会将指令解析成 for 属性以及 alias 属性，而“v-if”会将条件都存入 ifConditions 数组中。 12345678910111213141516171819202122function processFor (el) &#123; let exp; if ((exp = getAndRemoveAttr(el, &apos;v-for&apos;))) &#123; const inMatch = exp.match(forAliasRE); el.for = inMatch[2].trim(); el.alias = inMatch[1].trim(); &#125;&#125;function processIf (el) &#123; const exp = getAndRemoveAttr(el, &apos;v-if&apos;); if (exp) &#123; el.if = exp; if (!el.ifConditions) &#123; el.ifConditions = []; &#125; el.ifConditions.push(&#123; exp: exp, block: el &#125;); &#125;&#125; 到这里，我们已经把 parse 的过程介绍完了，接下来看一下 optimize。 optimizeoptimize 主要作用就跟它的名字一样，用作「优化」。 这个涉及到后面要讲 patch 的过程，因为 patch 的过程实际上是将 VNode 节点进行一层一层的比对，然后将「差异」更新到视图上。那么一些静态节点是不会根据数据变化而产生变化的，这些节点我们没有比对的需求，是不是可以跳过这些静态节点的比对，从而节省一些性能呢？ 那么我们就需要为静态的节点做上一些「标记」，在 patch 的时候我们就可以直接跳过这些被标记的节点的比对，从而达到「优化」的目的。 经过 optimize 这层的处理，每个节点会加上 static 属性，用来标记是否是静态的。 得到如下结果。 1234567891011121314151617181920212223242526272829303132333435&#123; &apos;attrsMap&apos;: &#123; &apos;:class&apos;: &apos;c&apos;, &apos;class&apos;: &apos;demo&apos;, &apos;v-if&apos;: &apos;isShow&apos; &#125;, &apos;classBinding&apos;: &apos;c&apos;, &apos;if&apos;: &apos;isShow&apos;, &apos;ifConditions&apos;: [ &apos;exp&apos;: &apos;isShow&apos; ], &apos;staticClass&apos;: &apos;demo&apos;, &apos;tag&apos;: &apos;div&apos;, /* 静态标志 */ &apos;static&apos;: false, &apos;children&apos;: [ &#123; &apos;attrsMap&apos;: &#123; &apos;v-for&apos;: &quot;item in sz&quot; &#125;, &apos;static&apos;: false, &apos;alias&apos;: &quot;item&quot;, &apos;for&apos;: &apos;sz&apos;, &apos;forProcessed&apos;: true, &apos;tag&apos;: &apos;span&apos;, &apos;children&apos;: [ &#123; &apos;expression&apos;: &apos;_s(item)&apos;, &apos;text&apos;: &apos;&#123;&#123;item&#125;&#125;&apos;, &apos;static&apos;: false &#125; ] &#125; ]&#125; 我们用代码实现一下 optimize 函数。 isStatic首先实现一个 isStatic 函数，传入一个 node 判断该 node 是否是静态节点。判断的标准是当 type 为 2（表达式节点）则是非静态节点，当 type 为 3（文本节点）的时候则是静态节点，当然，如果存在 if 或者 for这样的条件的时候（表达式节点），也是非静态节点。 123456789function isStatic (node) &#123; if (node.type === 2) &#123; return false &#125; if (node.type === 3) &#123; return true &#125; return (!node.if &amp;&amp; !node.for);&#125; markStaticmarkStatic 为所有的节点标记上 static，遍历所有节点通过 isStatic 来判断当前节点是否是静态节点，此外，会遍历当前节点的所有子节点，如果子节点是非静态节点，那么当前节点也是非静态节点。 123456789101112function markStatic (node) &#123; node.static = isStatic(node); if (node.type === 1) &#123; for (let i = 0, l = node.children.length; i &lt; l; i++) &#123; const child = node.children[i]; markStatic(child); if (!child.static) &#123; node.static = false; &#125; &#125; &#125;&#125; markStaticRoots接下来是 markStaticRoots 函数，用来标记 staticRoot（静态根）。这个函数实现比较简单，简单来将就是如果当前节点是静态节点，同时满足该节点并不是只有一个文本节点左右子节点（作者认为这种情况的优化消耗会大于收益）时，标记 staticRoot 为 true，否则为 false。 12345678910111213function markStaticRoots (node) &#123; if (node.type === 1) &#123; if (node.static &amp;&amp; node.children.length &amp;&amp; !( node.children.length === 1 &amp;&amp; node.children[0].type === 3 )) &#123; node.staticRoot = true; return; &#125; else &#123; node.staticRoot = false; &#125; &#125;&#125; optimize有了以上的函数，就可以实现 optimize 了。 1234function optimize (rootAst) &#123; markStatic(rootAst); markStaticRoots(rootAst);&#125; generategenerate 会将 AST 转化成 render funtion 字符串，最终得到 render 的字符串以及 staticRenderFns 字符串。 首先带大家感受一下真实的 Vue.js 编译得到的结果。 1234567891011121314151617with(this)&#123; return (isShow) ? _c( &apos;div&apos;, &#123; staticClass: &quot;demo&quot;, class: c &#125;, _l( (sz), function(item)&#123; return _c(&apos;span&apos;,[_v(_s(item))]) &#125; ) ) : _e()&#125; 看到这里可能会纳闷了，这些 _c，_l 到底是什么？其实他们是 Vue.js 对一些函数的简写，比如说 _c 对应的是 createElement 这个函数。没关系，我们把它用 VNode 的形式写出来就会明白了，这个对接上一章写的 VNode 函数。 首先是第一层 div 节点。 123456render () &#123; return isShow ? (new VNode(&apos;div&apos;, &#123; &apos;staticClass&apos;: &apos;demo&apos;, &apos;class&apos;: c &#125;, [ /*这里还有子节点*/ ])) : createEmptyVNode();&#125; 然后我们在 children 中加上第二层 span 及其子文本节点节点。 12345678910111213141516171819202122/* 渲染v-for列表 */function renderList (val, render) &#123; let ret = new Array(val.length); for (i = 0, l = val.length; i &lt; l; i++) &#123; ret[i] = render(val[i], i); &#125;&#125;render () &#123; return isShow ? (new VNode(&apos;div&apos;, &#123; &apos;staticClass&apos;: &apos;demo&apos;, &apos;class&apos;: c &#125;, /* begin */ renderList(sz, (item) =&gt; &#123; return new VNode(&apos;span&apos;, &#123;&#125;, [ createTextVNode(item); ]); &#125;) /* end */ )) : createEmptyVNode();&#125; 那我们如何来实现一个 generate 呢？ genIf首先实现一个处理 if 条件的 genIf 函数。 1234567function genIf (el) &#123; el.ifProcessed = true; if (!el.ifConditions.length) &#123; return &apos;_e()&apos;; &#125; return `($&#123;el.ifConditions[0].exp&#125;)?$&#123;genElement(el.ifConditions[0].block)&#125;: _e()`&#125; genFor然后是处理 for 循环的函数。 12345678910111213function genFor (el) &#123; el.forProcessed = true; const exp = el.for; const alias = el.alias; const iterator1 = el.iterator1 ? `,$&#123;el.iterator1&#125;` : &apos;&apos;; const iterator2 = el.iterator2 ? `,$&#123;el.iterator2&#125;` : &apos;&apos;; return `_l(($&#123;exp&#125;),` + `function($&#123;alias&#125;$&#123;iterator1&#125;$&#123;iterator2&#125;)&#123;` + `return $&#123;genElement(el)&#125;` + &apos;&#125;)&apos;;&#125; genText处理文本节点的函数。 123function genText (el) &#123; return `_v($&#123;el.expression&#125;)`;&#125; genElement接下来实现一下 genElement，这是一个处理节点的函数，因为它依赖 genChildren 以及g enNode ，所以这三个函数放在一起讲。 genElement会根据当前节点是否有 if 或者 for 标记然后判断是否要用 genIf 或者 genFor 处理，否则通过 genChildren 处理子节点，同时得到 staticClass、class 等属性。 genChildren 比较简单，遍历所有子节点，通过 genNode 处理后用“，”隔开拼接成字符串。 genNode 则是根据 type 来判断该节点是用文本节点 genText 还是标签节点 genElement 来处理。 123456789101112131415161718192021222324252627282930313233function genNode (el) &#123; if (el.type === 1) &#123; return genElement(el); &#125; else &#123; return genText(el); &#125;&#125;function genChildren (el) &#123; const children = el.children; if (children &amp;&amp; children.length &gt; 0) &#123; return `$&#123;children.map(genNode).join(&apos;,&apos;)&#125;`; &#125;&#125;function genElement (el) &#123; if (el.if &amp;&amp; !el.ifProcessed) &#123; return genIf(el); &#125; else if (el.for &amp;&amp; !el.forProcessed) &#123; return genFor(el); &#125; else &#123; const children = genChildren(el); let code; code = `_c(&apos;$&#123;el.tag&#125;,&apos;&#123; staticClass: $&#123;el.attrsMap &amp;&amp; el.attrsMap[&apos;:class&apos;]&#125;, class: $&#123;el.attrsMap &amp;&amp; el.attrsMap[&apos;class&apos;]&#125;, &#125;$&#123; children ? `,$&#123;children&#125;` : &apos;&apos; &#125;)` return code; &#125;&#125; generate最后我们使用上面的函数来实现 generate，其实很简单，我们只需要将整个 AST 传入后判断是否为空，为空则返回一个 div 标签，否则通过 generate 来处理。 123456function generate (rootAst) &#123; const code = rootAst ? genElement(rootAst) : &apos;_c(&quot;div&quot;)&apos; return &#123; render: `with(this)&#123;return $&#123;code&#125;&#125;`, &#125;&#125; 经历过这些过程以后，我们已经把 template 顺利转成了 render function 了，接下来我们将介绍 patch 的过程，来看一下具体 VNode 节点如何进行差异的比对。 注：本节代码参考《template 模板是怎样通过 Compile 编译的》。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[总结 & 常见问题解答]]></title>
    <url>%2F2018%2F09%2F27%2F%E6%80%BB%E7%BB%93%20%26%20%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E8%A7%A3%E7%AD%94%2F</url>
    <content type="text"><![CDATA[总结在本小册的第一节中，笔者对 Vue.js 内部运行机制做了一个全局的概览，当时通过下面这张图把 Vue.js 拆分成一个一个小模块来介绍，之后通过这一系列小节的学习，相信大家已经对 Vue.js 内部的原理有了一个更进一步的了解，对这张图也再也不会感觉到那么陌生。 每个小节中的代码都是笔者根据 Vue.js 原理单独抽离出来写成的 Demo，大家可以在我的 Gtihub 上查看完整的代码 (见 VueDemo 项目)。 本小册对 Vue.js 原理进行了初步的介绍，希望能够起到一个抛砖引玉的作用，读者读完以后，可以利用这些基础对 Vue.js 进行一个更加深入的探索，相信会有更大的收获。 常见问题 怎么实现 this._test 改变而不是 this._data.test 改变触发更新？ 答：其实这中间有一个代理的过程。 1234567891011121314151617_proxy(options.data);function _proxy (data) &#123; const that = this; Object.keys(data).forEach(key =&gt; &#123; Object.defineProperty(that, key, &#123; configurable: true, enumerable: true, get: function proxyGetter () &#123; return that._data[key]; &#125;, set: function proxySetter (val) &#123; that._data[key] = val; &#125; &#125;) &#125;);&#125; 本质就是通过 Object.defineProperty 使在访问 this 上的某属性时从 this._data 中读取（写入）。 能不能将依赖收集中讲到的 dep.addSub(Dep.target) 改成 dep.addSub(new Watcher())呢？ 为了便于读者理解这部分内容，我将代码做了简化，实际上一个 Watcher 对象可能会在多个 Dep 中，并不是每次 addSub 都是一个新的 Watcher 对象，需依赖 Dep.target 进行收集（实际上 Dep.target 也是通过 Watcher 对象的 get 方法调用 pushTarget 将自身赋值给 Dep.target）。 最后从 2017 年 12 月开始写这本小册到现在差不多 2 个月的时间，虽说之前写过类似的内容，但是将 Vue.js 源码抽离成一个一个 Demo 还是花了很多时间，对于这本小册也是前前后后改了好几次才让自己满意。 因为读者的基础不一致，而小册的定位是偏向于对新手读者更加友好，所以我尽量用更加浅显易懂的方式去写这本小册的内容。希望大家可以通过这本小册初步掌握 Vue.js 的原理，掌握这些原理以后再去尝试阅读 Vue.js 源码，相信会事半功倍，也会对 Vue.js 有更深一层的理解。 End]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式系统的依赖收集追踪原理]]></title>
    <url>%2F2018%2F09%2F23%2F%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BE%9D%E8%B5%96%E6%94%B6%E9%9B%86%E8%BF%BD%E8%B8%AA%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[# 为什么要依赖收集？先举个栗子🌰 我们现在有这么一个 Vue 对象。 123456789101112new Vue(&#123; template: `&lt;div&gt; &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/span&gt; &lt;span&gt;&#123;&#123;text2&#125;&#125;&lt;/span&gt; &lt;div&gt;`, data: &#123; text1: &apos;text1&apos;, text2: &apos;text2&apos;, text3: &apos;text3&apos; &#125;&#125;); 然后我们做了这么一个操作。 1this.text3 = &apos;modify text3&apos;; 我们修改了 data 中 text3 的数据，但是因为视图中并不需要用到 text3 ，所以我们并不需要触发上一章所讲的 cb 函数来更新视图，调用 cb 显然是不正确的。 再来一个栗子🌰 假设我们现在有一个全局的对象，我们可能会在多个 Vue 对象中用到它进行展示。 12345678910111213141516171819let globalObj = &#123; text1: &apos;text1&apos;&#125;;let o1 = new Vue(&#123; template: `&lt;div&gt; &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/span&gt; &lt;div&gt;`, data: globalObj&#125;);let o2 = new Vue(&#123; template: `&lt;div&gt; &lt;span&gt;&#123;&#123;text1&#125;&#125;&lt;/span&gt; &lt;div&gt;`, data: globalObj&#125;); 这个时候，我们执行了如下操作。 1globalObj.text1 = &apos;hello,text1&apos;; 我们应该需要通知 o1 以及 o2 两个vm实例进行视图的更新，「依赖收集」会让 text1 这个数据知道“哦～有两个地方依赖我的数据，我变化的时候需要通知它们～”。 最终会形成数据与视图的一种对应关系，如下图。 接下来我们来介绍一下「依赖收集」是如何实现的。 订阅者 Dep首先我们来实现一个订阅者 Dep ，它的主要作用是用来存放 Watcher 观察者对象。 123456789101112131415161718class Dep &#123; constructor () &#123; /* 用来存放Watcher对象的数组 */ this.subs = []; &#125; /* 在subs中添加一个Watcher对象 */ addSub (sub) &#123; this.subs.push(sub); &#125; /* 通知所有Watcher对象更新视图 */ notify () &#123; this.subs.forEach((sub) =&gt; &#123; sub.update(); &#125;) &#125;&#125; 为了便于理解我们只实现了添加的部分代码，主要是两件事情： 用 addSub 方法可以在目前的 Dep 对象中增加一个 Watcher 的订阅操作； 用 notify 方法通知目前 Dep 对象的 subs 中的所有 Watcher 对象触发更新操作。 观察者 Watcher12345678910111213class Watcher &#123; constructor () &#123; /* 在new一个Watcher对象时将该对象赋值给Dep.target，在get中会用到 */ Dep.target = this; &#125; /* 更新视图的方法 */ update () &#123; console.log(&quot;视图更新啦～&quot;); &#125;&#125;Dep.target = null; 依赖收集接下来我们修改一下 defineReactive 以及 Vue 的构造函数，来完成依赖收集。 我们在闭包中增加了一个 Dep 类的对象，用来收集 Watcher 对象。在对象被「读」的时候，会触发 reactiveGetter 函数把当前的 Watcher 对象（存放在 Dep.target 中）收集到 Dep 类中去。之后如果当该对象被「写」的时候，则会触发 reactiveSetter 方法，通知 Dep 类调用 notify 来触发所有 Watcher 对象的 update 方法更新对应视图。 123456789101112131415161718192021222324252627282930function defineReactive (obj, key, val) &#123; /* 一个Dep类对象 */ const dep = new Dep(); Object.defineProperty(obj, key, &#123; enumerable: true, configurable: true, get: function reactiveGetter () &#123; /* 将Dep.target（即当前的Watcher对象存入dep的subs中） */ dep.addSub(Dep.target); return val; &#125;, set: function reactiveSetter (newVal) &#123; if (newVal === val) return; /* 在set的时候触发dep的notify来通知所有的Watcher对象更新视图 */ dep.notify(); &#125; &#125;);&#125;class Vue &#123; constructor(options) &#123; this._data = options.data; observer(this._data); /* 新建一个Watcher观察者对象，这时候Dep.target会指向这个Watcher对象 */ new Watcher(); /* 在这里模拟render的过程，为了触发test属性的get函数 */ console.log(&apos;render~&apos;, this._data.test); &#125;&#125; 小结总结一下。 首先在 observer 的过程中会注册 get 方法，该方法用来进行「依赖收集」。在它的闭包中会有一个 Dep 对象，这个对象用来存放 Watcher 对象的实例。其实「依赖收集」的过程就是把 Watcher 实例存放到对应的 Dep 对象中去。get 方法可以让当前的 Watcher 对象（Dep.target）存放到它的 subs 中（addSub）方法，在数据变化时，set 会调用 Dep 对象的 notify 方法通知它内部所有的 Watcher 对象进行视图更新。 这是 Object.defineProperty 的 set/get 方法处理的事情，那么「依赖收集」的前提条件还有两个： 触发 get 方法； 新建一个 Watcher 对象。 这个我们在 Vue 的构造类中处理。新建一个 Watcher 对象只需要 new 出来，这时候 Dep.target 已经指向了这个 new 出来的 Watcher 对象来。而触发 get 方法也很简单，实际上只要把 render function 进行渲染，那么其中的依赖的对象都会被「读取」，这里我们通过打印来模拟这个过程，读取 test 来触发 get 进行「依赖收集」。 本章我们介绍了「依赖收集」的过程，配合之前的响应式原理，已经把整个「响应式系统」介绍完毕了。其主要就是 get 进行「依赖收集」。set 通过观察者来更新视图，配合下图仔细捋一捋，相信一定能搞懂它！ 注：本节代码参考《响应式系统的依赖收集追踪原理》。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[响应式系统的基本原理]]></title>
    <url>%2F2018%2F09%2F14%2F%E5%93%8D%E5%BA%94%E5%BC%8F%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[响应式系统Vue.js 是一款 MVVM 框架，数据模型仅仅是普通的 JavaScript 对象，但是对这些对象进行操作时，却能影响对应视图，它的核心实现就是「响应式系统」。尽管我们在使用 Vue.js 进行开发时不会直接修改「响应式系统」，但是理解它的实现有助于避开一些常见的「坑」，也有助于在遇见一些琢磨不透的问题时可以深入其原理来解决它。 Object.defineProperty首先我们来介绍一下 Object.defineProperty，Vue.js就是基于它实现「响应式系统」的。 首先是使用方法： 12345678/* obj: 目标对象 prop: 需要操作的目标对象的属性名 descriptor: 描述符 return value 传入对象*/Object.defineProperty(obj, prop, descriptor) descriptor的一些属性，简单介绍几个属性，具体可以参考 MDN 文档。 enumerable，属性是否可枚举，默认 false。 configurable，属性是否可以被修改或者删除，默认 false。 get，获取属性的方法。 set，设置属性的方法。 实现 observer（可观察的）知道了 Object.defineProperty 以后，我们来用它使对象变成可观察的。 这一部分的内容我们在第二小节中已经初步介绍过，在 init 的阶段会进行初始化，对数据进行「响应式化」。 为了便于理解，我们不考虑数组等复杂的情况，只对对象进行处理。 首先我们定义一个 cb 函数，这个函数用来模拟视图更新，调用它即代表更新视图，内部可以是一些更新视图的方法。 1234function cb (val) &#123; /* 渲染视图 */ console.log(&quot;视图更新啦～&quot;);&#125; 然后我们定义一个 defineReactive ，这个方法通过 Object.defineProperty 来实现对对象的「响应式」化，入参是一个 obj（需要绑定的对象）、key（obj的某一个属性），val（具体的值）。经过 defineReactive 处理以后，我们的 obj 的 key 属性在「读」的时候会触发 reactiveGetter 方法，而在该属性被「写」的时候则会触发 reactiveSetter 方法。 12345678910111213function defineReactive (obj, key, val) &#123; Object.defineProperty(obj, key, &#123; enumerable: true, /* 属性可枚举 */ configurable: true, /* 属性可被修改或删除 */ get: function reactiveGetter () &#123; return val; /* 实际上会依赖收集，下一小节会讲 */ &#125;, set: function reactiveSetter (newVal) &#123; if (newVal === val) return; cb(newVal); &#125; &#125;);&#125; 当然这是不够的，我们需要在上面再封装一层 observer 。这个函数传入一个 value（需要「响应式」化的对象），通过遍历所有属性的方式对该对象的每一个属性都通过 defineReactive 处理。（注：实际上 observer 会进行递归调用，为了便于理解去掉了递归的过程） 123456789function observer (value) &#123; if (!value || (typeof value !== &apos;object&apos;)) &#123; return; &#125; Object.keys(value).forEach((key) =&gt; &#123; defineReactive(value, key, value[key]); &#125;);&#125; 最后，让我们用 observer 来封装一个 Vue 吧！ 在 Vue 的构造函数中，对 options 的 data 进行处理，这里的 data 想必大家很熟悉，就是平时我们在写 Vue 项目时组件中的 data 属性（实际上是一个函数，这里当作一个对象来简单处理）。 1234567class Vue &#123; /* Vue构造类 */ constructor(options) &#123; this._data = options.data; observer(this._data); &#125;&#125; 这样我们只要 new 一个 Vue 对象，就会将 data 中的数据进行「响应式」化。如果我们对 data 的属性进行下面的操作，就会触发 cb 方法更新视图。 123456let o = new Vue(&#123; data: &#123; test: &quot;I am test.&quot; &#125;&#125;);o._data.test = &quot;hello,world.&quot;; /* 视图更新啦～ */ 至此，响应式原理已经介绍完了，接下来让我们学习「响应式系统」的另一部分 ——「依赖收集」。 注：本节代码参考《响应式系统的基本原理》。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据状态更新时的差异 diff 及 patch 机制]]></title>
    <url>%2F2018%2F09%2F09%2F%E6%95%B0%E6%8D%AE%E7%8A%B6%E6%80%81%E6%9B%B4%E6%96%B0%E6%97%B6%E7%9A%84%E5%B7%AE%E5%BC%82%20diff%20%E5%8F%8A%20patch%20%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[数据更新视图之前讲到，在对 model 进行操作对时候，会触发对应 Dep 中的 Watcher 对象。Watcher 对象会调用对应的 update 来修改视图。最终是将新产生的 VNode 节点与老 VNode 进行一个 patch 的过程，比对得出「差异」，最终将这些「差异」更新到视图上。 这一章就来介绍一下这个 patch 的过程，因为 patch 过程本身比较复杂，这一章的内容会比较多，但是不要害怕，我们逐块代码去看，一定可以理解。 跨平台因为使用了 Virtual DOM 的原因，Vue.js具有了跨平台的能力，Virtual DOM 终归只是一些 JavaScript 对象罢了，那么最终是如何调用不同平台的 API 的呢？ 这就需要依赖一层适配层了，将不同平台的 API 封装在内，以同样的接口对外提供。 123456789101112131415161718192021const nodeOps = &#123; setTextContent (text) &#123; if (platform === &apos;weex&apos;) &#123; node.parentNode.setAttr(&apos;value&apos;, text); &#125; else if (platform === &apos;web&apos;) &#123; node.textContent = text; &#125; &#125;, parentNode () &#123; //...... &#125;, removeChild () &#123; //...... &#125;, nextSibling () &#123; //...... &#125;, insertBefore () &#123; //...... &#125;&#125; 举个例子，现在我们有上述一个 nodeOps 对象做适配，根据 platform 区分不同平台来执行当前平台对应的API，而对外则是提供了一致的接口，供 Virtual DOM 来调用。 一些API接下来我们来介绍其他的一些 API，这些API在下面 patch 的过程中会被用到，他们最终都会调用 nodeOps 中的相应函数来操作平台。 insert 用来在 parent 这个父节点下插入一个子节点，如果指定了 ref 则插入到 ref 这个子节点前面。 1234567891011function insert (parent, elm, ref) &#123; if (parent) &#123; if (ref) &#123; if (ref.parentNode === parent) &#123; nodeOps.insertBefore(parent, elm, ref); &#125; &#125; else &#123; nodeOps.appendChild(parent, elm) &#125; &#125;&#125; createElm 用来新建一个节点， tag 存在创建一个标签节点，否则创建一个文本节点。 12345678function createElm (vnode, parentElm, refElm) &#123; if (vnode.tag) &#123; insert(parentElm, nodeOps.createElement(vnode.tag), refElm); &#125; else &#123; insert(parentElm, nodeOps.createTextNode(vnode.text), refElm); &#125;&#125; addVnodes 用来批量调用 createElm 新建节点。 12345function addVnodes (parentElm, refElm, vnodes, startIdx, endIdx) &#123; for (; startIdx &lt;= endIdx; ++startIdx) &#123; createElm(vnodes[startIdx], parentElm, refElm); &#125;&#125; removeNode 用来移除一个节点。 123456function removeNode (el) &#123; const parent = nodeOps.parentNode(el); if (parent) &#123; nodeOps.removeChild(parent, el); &#125;&#125; removeVnodes 会批量调用 removeNode 移除节点。 12345678function removeVnodes (parentElm, vnodes, startIdx, endIdx) &#123; for (; startIdx &lt;= endIdx; ++startIdx) &#123; const ch = vnodes[startIdx] if (ch) &#123; removeNode(ch.elm); &#125; &#125;&#125; patch首先说一下 patch 的核心 diff 算法，我们用 diff 算法可以比对出两颗树的「差异」，我们来看一下，假设我们现在有如下两颗树，它们分别是新老 VNode 节点，这时候到了 patch 的过程，我们需要将他们进行比对。 diff 算法是通过同层的树节点进行比较而非对树进行逐层搜索遍历的方式，所以时间复杂度只有 O(n)，是一种相当高效的算法，如下图。 。 这张图中的相同颜色的方块中的节点会进行比对，比对得到「差异」后将这些「差异」更新到视图上。因为只进行同层级的比对，所以十分高效。 patch 的过程相当复杂，我们先用简单的代码来看一下。 1234567891011121314function patch (oldVnode, vnode, parentElm) &#123; if (!oldVnode) &#123; addVnodes(parentElm, null, vnode, 0, vnode.length - 1); &#125; else if (!vnode) &#123; removeVnodes(parentElm, oldVnode, 0, oldVnode.length - 1); &#125; else &#123; if (sameVnode(oldVNode, vnode)) &#123; patchVnode(oldVNode, vnode); &#125; else &#123; removeVnodes(parentElm, oldVnode, 0, oldVnode.length - 1); addVnodes(parentElm, null, vnode, 0, vnode.length - 1); &#125; &#125;&#125; 因为 patch 的主要功能是比对两个 VNode 节点，将「差异」更新到视图上，所以入参有新老两个 VNode 以及父节点的 element 。我们来逐步捋一下逻辑， addVnodes 、 removeVnodes 等函数后面会讲。 首先在 oldVnode（老 VNode 节点）不存在的时候，相当于新的 VNode 替代原本没有的节点，所以直接用 addVnodes 将这些节点批量添加到 parentElm 上。 123if (!oldVnode) &#123; addVnodes(parentElm, null, vnode, 0, vnode.length - 1);&#125; 然后同理，在 vnode（新 VNode 节点）不存在的时候，相当于要把老的节点删除，所以直接使用 removeVnodes 进行批量的节点删除即可。 123else if (!vnode) &#123; removeVnodes(parentElm, oldVnode, 0, oldVnode.length - 1);&#125; 最后一种情况，当 oldVNode 与 vnode 都存在的时候，需要判断它们是否属于 sameVnode（相同的节点）。如果是则进行patchVnode（比对 VNode ）操作，否则删除老节点，增加新节点。 123456if (sameVnode(oldVNode, vnode)) &#123; patchVnode(oldVNode, vnode);&#125; else &#123; removeVnodes(parentElm, oldVnode, 0, oldVnode.length - 1); addVnodes(parentElm, null, vnode, 0, vnode.length - 1);&#125; sameVnode上面这些比较好理解，下面我们来看看什么情况下两个 VNode 会属于 sameVnode （相同的节点）呢？ 1234567891011121314151617function sameVnode () &#123; return ( a.key === b.key &amp;&amp; a.tag === b.tag &amp;&amp; a.isComment === b.isComment &amp;&amp; (!!a.data) === (!!b.data) &amp;&amp; sameInputType(a, b) )&#125;function sameInputType (a, b) &#123; if (a.tag !== &apos;input&apos;) return true let i const typeA = (i = a.data) &amp;&amp; (i = i.attrs) &amp;&amp; i.type const typeB = (i = b.data) &amp;&amp; (i = i.attrs) &amp;&amp; i.type return typeA === typeB&#125; sameVnode 其实很简单，只有当 key、 tag、 isComment（是否为注释节点）、 data同时定义（或不定义），同时满足当标签类型为 input 的时候 type 相同（某些浏览器不支持动态修改类型，所以他们被视为不同类型）即可。 patchVnode之前patch的过程还剩下 patchVnode 这个函数没有讲，这也是最复杂的一个，我们现在来看一下。因为这个函数是在符合 sameVnode 的条件下触发的，所以会进行「比对」。 123456789101112131415161718192021222324252627282930function patchVnode (oldVnode, vnode) &#123; if (oldVnode === vnode) &#123; return; &#125; if (vnode.isStatic &amp;&amp; oldVnode.isStatic &amp;&amp; vnode.key === oldVnode.key) &#123; vnode.elm = oldVnode.elm; vnode.componentInstance = oldVnode.componentInstance; return; &#125; const elm = vnode.elm = oldVnode.elm; const oldCh = oldVnode.children; const ch = vnode.children; if (vnode.text) &#123; nodeOps.setTextContent(elm, vnode.text); &#125; else &#123; if (oldCh &amp;&amp; ch &amp;&amp; (oldCh !== ch)) &#123; updateChildren(elm, oldCh, ch); &#125; else if (ch) &#123; if (oldVnode.text) nodeOps.setTextContent(elm, &apos;&apos;); addVnodes(elm, null, ch, 0, ch.length - 1); &#125; else if (oldCh) &#123; removeVnodes(elm, oldCh, 0, oldCh.length - 1) &#125; else if (oldVnode.text) &#123; nodeOps.setTextContent(elm, &apos;&apos;) &#125; &#125;&#125; 首先在新老 VNode 节点相同的情况下，就不需要做任何改变了，直接 return 掉。 123if (oldVnode === vnode) &#123; return;&#125; 下面的这种情况也比较简单，在当新老 VNode 节点都是 isStatic（静态的），并且 key 相同时，只要将 componentInstance 与 elm 从老 VNode 节点“拿过来”即可。这里的 isStatic 也就是前面提到过的「编译」的时候会将静态节点标记出来，这样就可以跳过比对的过程。 12345if (vnode.isStatic &amp;&amp; oldVnode.isStatic &amp;&amp; vnode.key === oldVnode.key) &#123; vnode.elm = oldVnode.elm; vnode.componentInstance = oldVnode.componentInstance; return;&#125; 接下来，当新 VNode 节点是文本节点的时候，直接用 setTextContent 来设置 text，这里的 nodeOps 是一个适配层，根据不同平台提供不同的操作平台 DOM 的方法，实现跨平台。 123if (vnode.text) &#123; nodeOps.setTextContent(elm, vnode.text);&#125; 当新 VNode 节点是非文本节点当时候，需要分几种情况。 oldCh 与 ch 都存在且不相同时，使用 updateChildren 函数来更新子节点，这个后面重点讲。 如果只有 ch 存在的时候，如果老节点是文本节点则先将节点的文本清除，然后将 ch 批量插入插入到节点elm下。 同理当只有 oldch 存在时，说明需要将老节点通过 removeVnodes 全部清除。 最后一种情况是当只有老节点是文本节点的时候，清除其节点文本内容。 12345678910if (oldCh &amp;&amp; ch &amp;&amp; (oldCh !== ch)) &#123; updateChildren(elm, oldCh, ch);&#125; else if (ch) &#123; if (oldVnode.text) nodeOps.setTextContent(elm, &apos;&apos;); addVnodes(elm, null, ch, 0, ch.length - 1);&#125; else if (oldCh) &#123; removeVnodes(elm, oldCh, 0, oldCh.length - 1)&#125; else if (oldVnode.text) &#123; nodeOps.setTextContent(elm, &apos;&apos;)&#125; updateChildren接下来就要讲一下 updateChildren 函数了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263function updateChildren (parentElm, oldCh, newCh) &#123; let oldStartIdx = 0; let newStartIdx = 0; let oldEndIdx = oldCh.length - 1; let oldStartVnode = oldCh[0]; let oldEndVnode = oldCh[oldEndIdx]; let newEndIdx = newCh.length - 1; let newStartVnode = newCh[0]; let newEndVnode = newCh[newEndIdx]; let oldKeyToIdx, idxInOld, elmToMove, refElm; while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) &#123; if (!oldStartVnode) &#123; oldStartVnode = oldCh[++oldStartIdx]; &#125; else if (!oldEndVnode) &#123; oldEndVnode = oldCh[--oldEndIdx]; &#125; else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode); oldStartVnode = oldCh[++oldStartIdx]; newStartVnode = newCh[++newStartIdx]; &#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode); oldEndVnode = oldCh[--oldEndIdx]; newEndVnode = newCh[--newEndIdx]; &#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; patchVnode(oldStartVnode, newEndVnode); nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)); oldStartVnode = oldCh[++oldStartIdx]; newEndVnode = newCh[--newEndIdx]; &#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; patchVnode(oldEndVnode, newStartVnode); nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm); oldEndVnode = oldCh[--oldEndIdx]; newStartVnode = newCh[++newStartIdx]; &#125; else &#123; let elmToMove = oldCh[idxInOld]; if (!oldKeyToIdx) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); idxInOld = newStartVnode.key ? oldKeyToIdx[newStartVnode.key] : null; if (!idxInOld) &#123; createElm(newStartVnode, parentElm); newStartVnode = newCh[++newStartIdx]; &#125; else &#123; elmToMove = oldCh[idxInOld]; if (sameVnode(elmToMove, newStartVnode)) &#123; patchVnode(elmToMove, newStartVnode); oldCh[idxInOld] = undefined; nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm); newStartVnode = newCh[++newStartIdx]; &#125; else &#123; createElm(newStartVnode, parentElm); newStartVnode = newCh[++newStartIdx]; &#125; &#125; &#125; &#125; if (oldStartIdx &gt; oldEndIdx) &#123; refElm = (newCh[newEndIdx + 1]) ? newCh[newEndIdx + 1].elm : null; addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx); &#125; else if (newStartIdx &gt; newEndIdx) &#123; removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx); &#125;&#125; 看到代码那么多先不要着急，我们还是一点一点地讲解。 首先我们定义 oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 分别是新老两个 VNode 的两边的索引，同时 oldStartVnode、newStartVnode、oldEndVnode 以及 newEndVnode 分别指向这几个索引对应的 VNode 节点。 接下来是一个 while 循环，在这过程中，oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 会逐渐向中间靠拢。 1while (oldStartIdx &lt;= oldEndIdx &amp;&amp; newStartIdx &lt;= newEndIdx) 首先当 oldStartVnode 或者 oldEndVnode 不存在的时候，oldStartIdx 与 oldEndIdx 继续向中间靠拢，并更新对应的 oldStartVnode 与 oldEndVnode 的指向（注：下面讲到的 oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 移动都会伴随着 oldStartVnode、newStartVnode、oldEndVnode 以及 newEndVnode 的指向的变化，之后的部分只会讲 Idx 的移动）。 12345if (!oldStartVnode) &#123; oldStartVnode = oldCh[++oldStartIdx];&#125; else if (!oldEndVnode) &#123; oldEndVnode = oldCh[--oldEndIdx];&#125; 接下来这一块，是将 oldStartIdx、newStartIdx、oldEndIdx 以及 newEndIdx 两两比对的过程，一共会出现 2*2=4 种情况。 12345678910111213141516171819 else if (sameVnode(oldStartVnode, newStartVnode)) &#123; patchVnode(oldStartVnode, newStartVnode); oldStartVnode = oldCh[++oldStartIdx]; newStartVnode = newCh[++newStartIdx];&#125; else if (sameVnode(oldEndVnode, newEndVnode)) &#123; patchVnode(oldEndVnode, newEndVnode); oldEndVnode = oldCh[--oldEndIdx]; newEndVnode = newCh[--newEndIdx];&#125; else if (sameVnode(oldStartVnode, newEndVnode)) &#123; patchVnode(oldStartVnode, newEndVnode); nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm)); oldStartVnode = oldCh[++oldStartIdx]; newEndVnode = newCh[--newEndIdx];&#125; else if (sameVnode(oldEndVnode, newStartVnode)) &#123; patchVnode(oldEndVnode, newStartVnode); nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm); oldEndVnode = oldCh[--oldEndIdx]; newStartVnode = newCh[++newStartIdx];&#125; 首先是 oldStartVnode 与 newStartVnode 符合 sameVnode 时，说明老 VNode 节点的头部与新 VNode 节点的头部是相同的 VNode 节点，直接进行 patchVnode，同时 oldStartIdx 与 newStartIdx 向后移动一位。 其次是 oldEndVnode 与 newEndVnode 符合 sameVnode，也就是两个 VNode 的结尾是相同的 VNode，同样进行 patchVnode 操作并将 oldEndVnode 与 newEndVnode 向前移动一位。 接下来是两种交叉的情况。 先是 oldStartVnode 与 newEndVnode 符合 sameVnode 的时候，也就是老 VNode 节点的头部与新 VNode 节点的尾部是同一节点的时候，将 oldStartVnode.elm 这个节点直接移动到 oldEndVnode.elm 这个节点的后面即可。然后 oldStartIdx 向后移动一位，newEndIdx 向前移动一位。 同理，oldEndVnode 与 newStartVnode 符合 sameVnode 时，也就是老 VNode 节点的尾部与新 VNode 节点的头部是同一节点的时候，将 oldEndVnode.elm 插入到 oldStartVnode.elm 前面。同样的，oldEndIdx 向前移动一位，newStartIdx 向后移动一位。 最后是当以上情况都不符合的时候，这种情况怎么处理呢？ 123456789101112131415161718192021222324252627282930else &#123; let elmToMove = oldCh[idxInOld]; if (!oldKeyToIdx) oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx); idxInOld = newStartVnode.key ? oldKeyToIdx[newStartVnode.key] : null; if (!idxInOld) &#123; createElm(newStartVnode, parentElm); newStartVnode = newCh[++newStartIdx]; &#125; else &#123; elmToMove = oldCh[idxInOld]; if (sameVnode(elmToMove, newStartVnode)) &#123; patchVnode(elmToMove, newStartVnode); oldCh[idxInOld] = undefined; nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm); newStartVnode = newCh[++newStartIdx]; &#125; else &#123; createElm(newStartVnode, parentElm); newStartVnode = newCh[++newStartIdx]; &#125; &#125;&#125;function createKeyToOldIdx (children, beginIdx, endIdx) &#123; let i, key const map = &#123;&#125; for (i = beginIdx; i &lt;= endIdx; ++i) &#123; key = children[i].key if (isDef(key)) map[key] = i &#125; return map&#125; createKeyToOldIdx 的作用是产生 key 与 index 索引对应的一个 map 表。比如说： 12345[ &#123;xx: xx, key: &apos;key0&apos;&#125;, &#123;xx: xx, key: &apos;key1&apos;&#125;, &#123;xx: xx, key: &apos;key2&apos;&#125;] 在经过 createKeyToOldIdx 转化以后会变成： 12345&#123; key0: 0, key1: 1, key2: 2&#125; 我们可以根据某一个 key 的值，快速地从 oldKeyToIdx（createKeyToOldIdx 的返回值）中获取相同 key 的节点的索引 idxInOld，然后找到相同的节点。 如果没有找到相同的节点，则通过 createElm 创建一个新节点，并将 newStartIdx 向后移动一位。 1234if (!idxInOld) &#123; createElm(newStartVnode, parentElm); newStartVnode = newCh[++newStartIdx];&#125; 否则如果找到了节点，同时它符合 sameVnode，则将这两个节点进行 patchVnode，将该位置的老节点赋值 undefined（之后如果还有新节点与该节点key相同可以检测出来提示已有重复的 key ），同时将 newStartVnode.elm 插入到 oldStartVnode.elm 的前面。同理，newStartIdx 往后移动一位。 123456789else &#123; elmToMove = oldCh[idxInOld]; if (sameVnode(elmToMove, newStartVnode)) &#123; patchVnode(elmToMove, newStartVnode); oldCh[idxInOld] = undefined; nodeOps.insertBefore(parentElm, newStartVnode.elm, oldStartVnode.elm); newStartVnode = newCh[++newStartIdx]; &#125;&#125; 如果不符合 sameVnode，只能创建一个新节点插入到 parentElm 的子节点中，newStartIdx 往后移动一位。 1234else &#123; createElm(newStartVnode, parentElm); newStartVnode = newCh[++newStartIdx];&#125; 最后一步就很容易啦，当 while 循环结束以后，如果 oldStartIdx &gt; oldEndIdx，说明老节点比对完了，但是新节点还有多的，需要将新节点插入到真实 DOM 中去，调用 addVnodes 将这些节点插入即可。 同理，如果满足 newStartIdx &gt; newEndIdx 条件，说明新节点比对完了，老节点还有多，将这些无用的老节点通过 removeVnodes 批量删除即可。 123456if (oldStartIdx &gt; oldEndIdx) &#123; refElm = (newCh[newEndIdx + 1]) ? newCh[newEndIdx + 1].elm : null; addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx);&#125; else if (newStartIdx &gt; newEndIdx) &#123; removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);&#125; 到这里，比对的核心实现已经讲完了，这部分比较复杂，不过仔细地梳理一下比对的过程，相信一定能够理解得更加透彻的。 注：本节代码参考《数据状态更新时的差异 diff 及 patch 机制》。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实现 Virtual DOM 下的一个 VNode 节点]]></title>
    <url>%2F2018%2F09%2F06%2F%E5%AE%9E%E7%8E%B0%20Virtual%20DOM%20%E4%B8%8B%E7%9A%84%E4%B8%80%E4%B8%AA%20VNode%20%E8%8A%82%E7%82%B9%2F</url>
    <content type="text"><![CDATA[什么是VNode我们知道，render function 会被转化成 VNode 节点。Virtual DOM 其实就是一棵以 JavaScript 对象（VNode 节点）作为基础的树，用对象属性来描述节点，实际上它只是一层对真实 DOM 的抽象。最终可以通过一系列操作使这棵树映射到真实环境上。由于 Virtual DOM 是以 JavaScript 对象为基础而不依赖真实平台环境，所以使它具有了跨平台的能力，比如说浏览器平台、Weex、Node 等。 实现一个VNodeVNode 归根结底就是一个 JavaScript 对象，只要这个类的一些属性可以正确直观地描述清楚当前节点的信息即可。我们来实现一个简单的 VNode 类，加入一些基本属性，为了便于理解，我们先不考虑复杂的情况。 1234567891011121314class VNode &#123; constructor (tag, data, children, text, elm) &#123; /*当前节点的标签名*/ this.tag = tag; /*当前节点的一些数据信息，比如props、attrs等数据*/ this.data = data; /*当前节点的子节点，是一个数组*/ this.children = children; /*当前节点的文本*/ this.text = text; /*当前虚拟节点对应的真实dom节点*/ this.elm = elm; &#125;&#125; 比如我目前有这么一个 Vue 组件。 12345&lt;template&gt; &lt;span class=&quot;demo&quot; v-show=&quot;isShow&quot;&gt; This is a span. &lt;/span&gt;&lt;/template&gt; 用 JavaScript 代码形式就是这样的。 1234567891011121314151617181920function render () &#123; return new VNode( &apos;span&apos;, &#123; /* 指令集合数组 */ directives: [ &#123; /* v-show指令 */ rawName: &apos;v-show&apos;, expression: &apos;isShow&apos;, name: &apos;show&apos;, value: true &#125; ], /* 静态class */ staticClass: &apos;demo&apos; &#125;, [ new VNode(undefined, undefined, undefined, &apos;This is a span.&apos;) ] );&#125; 看看转换成 VNode 以后的情况。 123456789101112131415161718192021222324252627&#123; tag: &apos;span&apos;, data: &#123; /* 指令集合数组 */ directives: [ &#123; /* v-show指令 */ rawName: &apos;v-show&apos;, expression: &apos;isShow&apos;, name: &apos;show&apos;, value: true &#125; ], /* 静态class */ staticClass: &apos;demo&apos; &#125;, text: undefined, children: [ /* 子节点是一个文本VNode节点 */ &#123; tag: undefined, data: undefined, text: &apos;This is a span.&apos;, children: undefined &#125; ]&#125; 然后我们可以将 VNode 进一步封装一下，可以实现一些产生常用 VNode 的方法。 创建一个空节点 12345function createEmptyVNode () &#123; const node = new VNode(); node.text = &apos;&apos;; return node;&#125; 创建一个文本节点 123function createTextVNode (val) &#123; return new VNode(undefined, undefined, undefined, String(val));&#125; 克隆一个 VNode 节点 12345678910function cloneVNode (node) &#123; const cloneVnode = new VNode( node.tag, node.data, node.children, node.text, node.elm ); return cloneVnode;&#125; 总的来说，VNode 就是一个 JavaScript 对象，用 JavaScript 对象的属性来描述当前节点的一些状态，用 VNode 节点的形式来模拟一棵 Virtual DOM 树。 注：本节代码参考《实现 Virtual DOM 下的一个 VNode 节点》。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[批量异步更新策略及 nextTick 原理]]></title>
    <url>%2F2018%2F09%2F03%2F%E6%89%B9%E9%87%8F%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E7%AD%96%E7%95%A5%E5%8F%8A%20nextTick%20%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[为什么要异步更新通过前面几个章节我们介绍，相信大家已经明白了 Vue.js 是如何在我们修改 data 中的数据后修改视图了。简单回顾一下，这里面其实就是一个“setter -&gt; Dep -&gt; Watcher -&gt; patch -&gt; 视图”的过程。 假设我们有如下这么一种情况。 123456&lt;template&gt; &lt;div&gt; &lt;div&gt;&#123;&#123;number&#125;&#125;&lt;/div&gt; &lt;div @click=&quot;handleClick&quot;&gt;click&lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 1234567891011121314export default &#123; data () &#123; return &#123; number: 0 &#125;; &#125;, methods: &#123; handleClick () &#123; for(let i = 0; i &lt; 1000; i++) &#123; this.number++; &#125; &#125; &#125;&#125; 当我们按下 click 按钮的时候，number 会被循环增加1000次。 那么按照之前的理解，每次 number 被 +1 的时候，都会触发 number 的 setter 方法，从而根据上面的流程一直跑下来最后修改真实 DOM。那么在这个过程中，DOM 会被更新 1000 次！太可怕了。 Vue.js 肯定不会以如此低效的方法来处理。Vue.js在默认情况下，每次触发某个数据的 setter 方法后，对应的 Watcher 对象其实会被 push 进一个队列 queue 中，在下一个 tick 的时候将这个队列 queue 全部拿出来 run（ Watcher 对象的一个方法，用来触发 patch 操作） 一遍。 那么什么是下一个 tick 呢？ nextTickVue.js 实现了一个 nextTick 函数，传入一个 cb ，这个 cb 会被存储到一个队列中，在下一个 tick 时触发队列中的所有 cb 事件。 因为目前浏览器平台并没有实现 nextTick 方法，所以 Vue.js 源码中分别用 Promise、setTimeout、setImmediate 等方式在 microtask（或是task）中创建一个事件，目的是在当前调用栈执行完毕以后（不一定立即）才会去执行这个事件。 笔者用 setTimeout 来模拟这个方法，当然，真实的源码中会更加复杂，笔者在小册中只讲原理，有兴趣了解源码中 nextTick 的具体实现的同学可以参考next-tick。 首先定义一个 callbacks 数组用来存储 nextTick，在下一个 tick 处理这些回调函数之前，所有的 cb 都会被存在这个 callbacks 数组中。pending 是一个标记位，代表一个等待的状态。 setTimeout 会在 task 中创建一个事件 flushCallbacks ，flushCallbacks 则会在执行时将 callbacks 中的所有 cb 依次执行。 1234567891011121314151617181920let callbacks = [];let pending = false;function nextTick (cb) &#123; callbacks.push(cb); if (!pending) &#123; pending = true; setTimeout(flushCallbacks, 0); &#125;&#125;function flushCallbacks () &#123; pending = false; const copies = callbacks.slice(0); callbacks.length = 0; for (let i = 0; i &lt; copies.length; i++) &#123; copies[i](); &#125;&#125; 再写 Watcher第一个例子中，当我们将 number 增加 1000 次时，先将对应的 Watcher 对象给 push 进一个队列 queue 中去，等下一个 tick 的时候再去执行，这样做是对的。但是有没有发现，另一个问题出现了？ 因为 number 执行 ++ 操作以后对应的 Watcher 对象都是同一个，我们并不需要在下一个 tick 的时候执行 1000 个同样的 Watcher 对象去修改界面，而是只需要执行一个 Watcher 对象，使其将界面上的 0 变成 1000 即可。 那么，我们就需要执行一个过滤的操作，同一个的 Watcher 在同一个 tick 的时候应该只被执行一次，也就是说队列 queue 中不应该出现重复的 Watcher 对象。 那么我们给 Watcher 对象起个名字吧～用 id 来标记每一个 Watcher 对象，让他们看起来“不太一样”。 实现 update 方法，在修改数据后由 Dep 来调用， 而 run 方法才是真正的触发 patch 更新视图的方法。 12345678910111213141516let uid = 0;class Watcher &#123; constructor () &#123; this.id = ++uid; &#125; update () &#123; console.log(&apos;watch&apos; + this.id + &apos; update&apos;); queueWatcher(this); &#125; run () &#123; console.log(&apos;watch&apos; + this.id + &apos;视图更新啦～&apos;); &#125;&#125; queueWatcher不知道大家注意到了没有？笔者已经将 Watcher 的 update 中的实现改成了 1queueWatcher(this); 将 Watcher 对象自身传递给 queueWatcher 方法。 我们来实现一下 queueWatcher 方法。 12345678910111213141516let has = &#123;&#125;;let queue = [];let waiting = false;function queueWatcher(watcher) &#123; const id = watcher.id; if (has[id] == null) &#123; has[id] = true; queue.push(watcher); if (!waiting) &#123; waiting = true; nextTick(flushSchedulerQueue); &#125; &#125;&#125; 我们使用一个叫做 has 的 map，里面存放 id -&gt; true ( false ) 的形式，用来判断是否已经存在相同的 Watcher 对象 （这样比每次都去遍历 queue 效率上会高很多）。 如果目前队列 queue 中还没有这个 Watcher 对象，则该对象会被 push 进队列 queue 中去。 waiting 是一个标记位，标记是否已经向 nextTick 传递了 flushSchedulerQueue 方法，在下一个 tick 的时候执行 flushSchedulerQueue 方法来 flush 队列 queue，执行它里面的所有 Watcher 对象的 run 方法。 flushSchedulerQueue123456789101112function flushSchedulerQueue () &#123; let watcher, id; for (index = 0; index &lt; queue.length; index++) &#123; watcher = queue[index]; id = watcher.id; has[id] = null; watcher.run(); &#125; waiting = false;&#125; 举个例子123456let watch1 = new Watcher();let watch2 = new Watcher();watch1.update();watch1.update();watch2.update(); 我们现在 new 了两个 Watcher 对象，因为修改了 data 的数据，所以我们模拟触发了两次 watch1 的 update 以及 一次 watch2 的 update。 假设没有批量异步更新策略的话，理论上应该执行 Watcher 对象的 run，那么会打印。 123456watch1 updatewatch1视图更新啦～watch1 updatewatch1视图更新啦～watch2 updatewatch2视图更新啦～ 实际上则执行 12345watch1 updatewatch1 updatewatch2 updatewatch1视图更新啦～watch2视图更新啦～ 这就是异步更新策略的效果，相同的 Watcher 对象会在这个过程中被剔除，在下一个 tick 的时候去更新视图，从而达到对我们第一个例子的优化。 我们再回过头聊一下第一个例子， number 会被不停地进行 ++ 操作，不断地触发它对应的 Dep 中的 Watcher 对象的 update 方法。然后最终 queue 中因为对相同 id 的 Watcher 对象进行了筛选，从而 queue 中实际上只会存在一个 number 对应的 Watcher 对象。在下一个 tick 的时候（此时 number 已经变成了 1000），触发 Watcher 对象的 run 方法来更新视图，将视图上的 number 从 0 直接变成 1000。 到这里，批量异步更新策略及 nextTick 原理已经讲完了，接下来让我们学习一下 Vuex 状态管理的工作原理。 注：本节代码参考《批量异步更新策略及 nextTick 原理》。]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型模式]]></title>
    <url>%2F2018%2F07%2F04%2F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[克隆自己生成新对象 相关代码实现123456789101112131415161718192021// 一个原型对象let prototype = &#123; getName:function () &#123; return this.first + ' ' + this.last &#125;, say: function () &#123; alert('hello') &#125;&#125;//基于原型创建xlet x = Object.create(prototype)x.first = 'A'x.last = 'B'alert(x.getName())x.say()//基于原型创建ylet y = Object.create(prototype)y.first = 'C'y.last = 'D'alert(y.getName())y.say()]]></content>
      <categories>
        <category>js中的设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模版方法模式和职责链模式]]></title>
    <url>%2F2018%2F07%2F04%2F%E6%A8%A1%E7%89%88%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%E5%92%8C%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[模版方法模式12345678910111213141516class Action &#123; handle() &#123; this.handle1() this.handle2() this.handle3() &#125; handle1() &#123; console.log('1') &#125; handle2() &#123; console.log('2') &#125; handle3() &#123; console.log('3') &#125;&#125; 职责链模式一个操作可能分为多个职责角色来完成，把这些角色都分开，然后用一个链串起来，将发起者和各个处理者进行隔离 123456789101112131415161718192021class Action &#123; constructor(name) &#123; this.name = name this.nextAction = null &#125; setNextAction(action) &#123; this.nextAction = action &#125; handle() &#123; console.log(`$&#123;this.name&#125;审批`) if (this.nextAction!=null)&#123; this.nextAction.handle() &#125; &#125;&#125;let a1 = new Action('组长')let a2 = new Action('经理')let a3 = new Action('总监')a1.setNextAction(a2)a2.setNextAction(a3)a1.handle()]]></content>
      <categories>
        <category>js中的设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[nginx location详解]]></title>
    <url>%2F2018%2F07%2F04%2Fnginx%20location%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[语法规则location [=|~|~*|^~] /uri/ {….} 123456789101112131415161718192021222324252627282930313233class Receiver &#123; exec() &#123; console.log('执行') &#125;&#125;class Command &#123; constructor(receiver) &#123; this.receiver = receiver &#125; cmd() &#123; console.log('执行命令') this.receiver.exec() &#125;&#125;class Invoker &#123; constructor(command) &#123; this.command = command &#125; invoke() &#123; console.log('开始') this.command.cmd() &#125;&#125;//士兵let soldier = new Receiver()//小号手let trumpeter = new Command(soldier)//将军let general = new Invoker(trumpeter)general.invoke()]]></content>
      <categories>
        <category>nginx</category>
      </categories>
      <tags>
        <tag>nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令模式]]></title>
    <url>%2F2018%2F07%2F04%2F%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[克隆自己生成新对象 相关代码实现123456789101112131415161718192021222324252627282930313233class Receiver &#123; exec() &#123; console.log('执行') &#125;&#125;class Command &#123; constructor(receiver) &#123; this.receiver = receiver &#125; cmd() &#123; console.log('执行命令') this.receiver.exec() &#125;&#125;class Invoker &#123; constructor(command) &#123; this.command = command &#125; invoke() &#123; console.log('开始') this.command.cmd() &#125;&#125;//士兵let soldier = new Receiver()//小号手let trumpeter = new Command(soldier)//将军let general = new Invoker(trumpeter)general.invoke()]]></content>
      <categories>
        <category>js中的设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue项目的nginx配置]]></title>
    <url>%2F2018%2F07%2F03%2Fvue%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%9A%84nginx%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[vue项目的config/index.js文件相关配置 1234567891011build: &#123; env: require('./prod.env'), index: path.resolve(__dirname, '../dist/index.html'), assetsRoot: path.resolve(__dirname, '../dist'), assetsSubDirectory: 'static', assetsPublicPath: '/weixin/', //项目名称 productionSourceMap: false, productionGzip: true, productionGzipExtensions: ['js', 'css'], bundleAnalyzerReport: process.env.npm_config_report &#125;, 对应的nginx配置 123456789101112131415161718192021222324252627282930313233343536server&#123; listen 80; server_name www.xxxxx.com; //访问web的域名 location ~ .*\.(html|htm|ico|txt|js|css|woff2?|eot|ttf|otf|png|jpe?g|gif|svg|exe)$ &#123; root html/xxxx/dist; index index.html index.htm index.jsp; &#125; // 当以html|htm|ico|txt|js|css|woff2?|eot|ttf|otf|png|jpe?g|gif|svg|exe这些文件结尾的文件找不到时就去html/xxxx/dist;就去这个目录去找 location /api &#123; index index.html index.htm index.jsp; rewrite $1 /; proxy_pass http://172.168.8.196:32/weixin; //web项目访问的服务器的域名 proxy_cookie_path /PKECUser /; proxy_set_header Host $host; proxy_set_header Host $host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header REMOTE-HOST $remote_addr; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; &#125; location /websocket &#123; rewrite $1 /; proxy_pass http://localhost:8082/; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection "upgrade"; proxy_read_timeout 86400; &#125; location ^~ /image&#123; root /usr/local/image; &#125; location ^~ /weixin &#123; alias html/xxxx/dist; &#125; // 访问链接匹配到weixin就会去访问web在服务器上的目录 location / &#123; try_files $uri $uri/ /index.html; &#125; //可以让vue项目的vuerouter的各个路由可以单独访问&#125; 提示 该web项目的访问的链接http://www.xxxxx.com/weixin]]></content>
      <categories>
        <category>nginx</category>
        <category>vue</category>
      </categories>
      <tags>
        <tag>nginx</tag>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态模式]]></title>
    <url>%2F2018%2F07%2F03%2F%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[相关代码实现12345678910111213141516171819202122232425262728293031323334353637class State &#123; constructor(color) &#123; this.color = color &#125; handle(context) &#123; console.log(`turn to $&#123;this.color&#125; light`) context.setState(this) &#125;&#125;class Context &#123; constructor() &#123; this.state = null &#125; getState() &#123; return this.state &#125; setState(state)&#123; this.state = state &#125;&#125;let context = new Context()let green = new State('green')let yellow = new State('yellow')let red = new State('red')green.handle(context)console.log(context.getState())yellow.handle(context)console.log(context.getState())red.handle(context)console.log(context.getState())green.handle(context) 场景1 收藏 取消收藏 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import StateMachine from 'javascript-state-machine'import $ from 'jquery'//初始化状态机模型let fm = new StateMachine(&#123; init: '收藏', transitions: [ &#123; name: 'doStore', from: '收藏', to:'取消收藏' &#125;, &#123; name: 'deleteStore', from: '取消收藏', to: '收藏' &#125; ], methods: &#123; //监听执行收藏 onDoStore: function () &#123; alert('收藏成功') updateText() &#125;, // 监听取消收藏 onDeleteStore: function () &#123; alert('已经取消收藏') updateText() &#125; &#125;&#125;)let $btn = $('#btn1')// 按钮点击事件$btn.click(function () &#123; if (fm.is('收藏'))&#123; fm.doStore() &#125;else &#123; fm.deleteStore() &#125;&#125;)//更新按钮的文案function updateText () &#123; $btn.text(fm.state)&#125;updateText() 场景2 Promise简单实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576import StateMachine from 'javascript-state-machine'//状态机模型let fsm = new StateMachine(&#123; init: 'pending', transitions: [ &#123; name: 'resolve', //事件名称 from: 'pending', to: 'fullfilled' &#125;, &#123; name: 'reject', //事件名称 from: 'pending', to: 'rejected' &#125; ], methods: &#123; // 监听 resolve onResolve: function (state,data) &#123; // state if (data) &#123; data.successList.forEach(fn =&gt; fn()) &#125; &#125;, // 监听 reject onReject: function (state,data) &#123; if (data) &#123; data.failList.forEach(fn =&gt; fn()) &#125; &#125; &#125;&#125;)//定义Promiseclass MyPromise &#123; constructor(fn) &#123; this.successList = [] this.failList = [] let _this = this fn(function () &#123; fsm.resolve(_this) &#125;,function () &#123; fsm.reject(_this) &#125;) &#125; then(successFn, failedFn)&#123; this.successList.push(successFn) this.failList.push(failedFn) &#125;&#125;function loadImg (src) &#123; const promise = new MyPromise(function (resolve,reject) &#123; let img = document.createElement('img') img.onload = function () &#123; resolve() &#125; img.onerror = function () &#123; reject() &#125; img.src = src &#125;) return promise&#125;let src = 'https://github.com/youguodong/blogImages/blob/master/设计模式/8.png?raw=true'let result = loadImg(src)result.then(function () &#123; console.log('ok1')&#125;,function () &#123; console.log('fail1')&#125;)result.then(function () &#123; console.log('ok2')&#125;,function () &#123; console.log('fail2')&#125;)]]></content>
      <categories>
        <category>js中的设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F2018%2F07%2F02%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[发布，订阅，一对多 相关代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344// 主题，保存状态，状态变化之后触发所有观察者对象class Subject &#123; constructor() &#123; this.state = 0 this.observers = [] &#125; getState() &#123; return this.state &#125; setState(state)&#123; this.state = state this.notifyAllObservers() &#125; notifyAllObservers() &#123; this.observers.forEach(observer =&gt; &#123; observer.update() &#125;) &#125; attach(observer) &#123; this.observers.push(observer) &#125;&#125;// 观察者class Observer &#123; constructor(name, subject) &#123; this.name = name this.subject = subject this.subject.attach(this) &#125; update() &#123; console.log(`$&#123;this.name&#125; update, state: $&#123;this.subject.getState()&#125;`) &#125;&#125;// 测试let s = new Subject()let o1 = new Observer('o1',s)let o2 = new Observer('o2',s)let o3 = new Observer('O3',s)s.setState(1)s.setState(2)s.setState(3) 场景1 网页时间绑定 12345678910111213141516&lt;body&gt; &lt;button id="btn1"&gt;btn&lt;/button&gt;&lt;/body&gt;&lt;script src="https://cdn.bootcss.com/jquery/3.3.0/jquery.js"&gt;&lt;/script&gt;&lt;script&gt; $('#btn1').click(function () &#123; console.log(1) &#125;) $('#btn2').click(function () &#123; console.log(2) &#125;) $('#btn3').click(function () &#123; console.log(3) &#125;)&lt;/script&gt; 场景2 Promise 123456789101112131415161718192021function loadImg () &#123; let promise = new Promise(function (resolve, reject) &#123; let img = document.createElement('img') img.onload = function () &#123; resolve(img) &#125; img.onerror = function () &#123; reject('图片加载失败') &#125; img.src = src &#125;) return promise&#125;let src = 'https://github.com/youguodong/blogImages/blob/master/设计模式/6.png?raw=true'let result = loadImg(src)result.then(function (img) &#123; console.log('width',img.width)&#125;).then(function (img) &#123; console.log('height',img.height)&#125;) 场景3 jQuery callbacks 12345678910111213141516&lt;script src="https://cdn.bootcss.com/jquery/3.3.0/jquery.js"&gt;&lt;/script&gt;&lt;script&gt;//自定义事件let callbacks = $.Callbacks()callbacks.add(function (info) &#123; console.log('fn1',info)&#125;)callbacks.add(function (info) &#123; console.log('fn2',info)&#125;)callbacks.add(function (info) &#123; console.log('fn3',info)&#125;)callbacks.fire('gogogo')callbacks.fire('hello world')&lt;/script&gt;]]></content>
      <categories>
        <category>js中的设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器模式]]></title>
    <url>%2F2018%2F07%2F01%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[相关代码实现12345678910111213141516171819202122232425262728293031323334class Iterator &#123; constructor(container) &#123; this.list = container.list this.index = 0 &#125; next() &#123; if (this.hasNext()) &#123; return this.list[this.index++] &#125; return null &#125; hasNext() &#123; if (this.index &gt;= this.list.length)&#123; return false &#125; return true &#125;&#125;class Container &#123; constructor(list) &#123; this.list = list &#125; getIterator() &#123; return new Iterator(this) &#125;&#125;let arr = [1,2,3,4,5,6]let container = new Container(arr)let iterator = container.getIterator()while (iterator.hasNext())&#123; console.log(iterator.next())&#125; 场景1 jQuery each 123456789101112131415161718192021222324252627&lt;body&gt; &lt;div id="div1"&gt; &lt;a href="#"&gt;a1&lt;/a&gt; &lt;a href="#"&gt;a2&lt;/a&gt; &lt;a href="#"&gt;a3&lt;/a&gt; &lt;a href="#"&gt;a4&lt;/a&gt; &lt;a href="#"&gt;a5&lt;/a&gt; &lt;a href="#"&gt;a6&lt;/a&gt; &lt;/div&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.0/jquery.js"&gt; &lt;/script&gt; &lt;script&gt; let arr = [1,2,3] let nodeList = document.getElementsByTagName('a') let $a = $('a') function each (data) &#123; let $data = $(data) $data.each(function (key, val) &#123; console.log(key,val) &#125;) &#125; each(arr) each(nodeList) each($a) &lt;/script&gt;&lt;/body&gt; 场景2 es6 Iterator 123456789101112131415161718192021222324252627282930313233function each (data) &#123; let iterator = data[Symbol.iterator]() let item = &#123;done: false&#125; while (!item.done)&#123; item = iterator.next() if (!item.done)&#123; console.log(item.value) &#125; &#125;&#125;let arr = [1,2,3,4]let nodeList = document.getElementsByTagName('p')let m = new Map()m.set('a',100)m.set('b',100)each(arr)each(nodeList)each(m)//简化后function each (data) &#123; for (let item of data)&#123; console.log(item) &#125;&#125;let arr = [1,2,3,4]let nodeList = document.getElementsByTagName('p')let m = new Map()m.set('a',100)m.set('b',100)each(arr)each(nodeList)each(m)]]></content>
      <categories>
        <category>js中的设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桥接模式]]></title>
    <url>%2F2018%2F07%2F01%2F%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[用于把抽象化和实现化解耦，使得二者可以独立变化 #####使用桥接模式之前 相关代码实现 1234567891011121314151617181920class ColorShape &#123; yellowCircle() &#123; console.log('yellow circle') &#125; redCircle() &#123; console.log('red circle') &#125; yellowTriangle() &#123; console.log('yellow triangle') &#125; redTriangle() &#123; console.log('red triangle') &#125;&#125;let cs = new ColorShape()cs.yellowCircle()cs.redCircle()cs.yellowTriangle()cs.redTriangle() 使用桥接模式之后 相关代码实现 1234567891011121314151617181920212223class Color &#123; constructor(name) &#123; this.name = name &#125;&#125;class Shape &#123; constructor(name, color) &#123; this.name = name this.color = color &#125; draw() &#123; console.log(`$&#123;this.color.name&#125; $&#123;this.name&#125;`) &#125;&#125;let red = new Color('red')let yellow = new Color('yellow')let cicle = new Shape('cicle',red)cicle.draw()let triangle = new Shape('triangle',yellow)triangle.draw()]]></content>
      <categories>
        <category>js中的设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[外观模式]]></title>
    <url>%2F2018%2F07%2F01%2F%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[相关代码实现1234567891011function bindEvent (elem, type, selector, fn) &#123; if (fn == null)&#123; fn = selector selector = null &#125; // ****&#125;//调用bindEvent(elem,'click','#div1',fn)bindEvent(elem,'click',fn)]]></content>
      <categories>
        <category>js中的设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2018%2F06%2F28%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[使用者无权访问目标对象，中间加代理，通过代理做授权和控制 相关代码实现1234567891011121314151617181920212223class ReadImg &#123; constructor(fileName) &#123; this.fileName = fileName this.loadFromDisk() &#125; display() &#123; console.log('display...' + this.fileName) &#125; loadFromDisk() &#123; console.log('loading...' + this.fileName) &#125;&#125;class ProxyImg &#123; constructor(fileName) &#123; this.realImg = new ReadImg(fileName) &#125; display() &#123; this.realImg.display() &#125;&#125;let proxyImg = new ProxyImg('1.png')proxyImg.display() 使用场景场景1 网页事件代理 1234567891011121314151617181920212223&lt;body&gt; &lt;div id="div1"&gt; &lt;a href="#"&gt;a1&lt;/a&gt; &lt;a href="#"&gt;a2&lt;/a&gt; &lt;a href="#"&gt;a3&lt;/a&gt; &lt;a href="#"&gt;a4&lt;/a&gt; &lt;a href="#"&gt;a5&lt;/a&gt; &lt;a href="#"&gt;a6&lt;/a&gt; &lt;/div&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.0/jquery.js"&gt; &lt;/script&gt; &lt;script&gt; let div1 = document.getElementById('div1') div1.addEventListener('click',function (e) &#123; let target = e.target if (target.nodeName === 'A')&#123; alert(target.innerHTML) &#125; &#125;) &lt;/script&gt; &lt;/body&gt; 场景2 jQuery $.proxy 1234567891011121314151617181920&lt;body&gt; &lt;div id="div1"&gt; &lt;a href="#"&gt;a1&lt;/a&gt; &lt;a href="#"&gt;a2&lt;/a&gt; &lt;a href="#"&gt;a3&lt;/a&gt; &lt;a href="#"&gt;a4&lt;/a&gt; &lt;a href="#"&gt;a5&lt;/a&gt; &lt;a href="#"&gt;a6&lt;/a&gt; &lt;/div&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.0/jquery.js" &lt;/script&gt; &lt;script&gt; $('#div1').click(function () &#123; let _this = this setTimeout(function () &#123; $(_this).css('background-color', 'yellow') &#125;,1000) &#125;) &lt;/script&gt;&lt;/body&gt; 123456789101112131415161718192021&lt;body&gt; &lt;div id="div1"&gt; &lt;a href="#"&gt;a1&lt;/a&gt; &lt;a href="#"&gt;a2&lt;/a&gt; &lt;a href="#"&gt;a3&lt;/a&gt; &lt;a href="#"&gt;a4&lt;/a&gt; &lt;a href="#"&gt;a5&lt;/a&gt; &lt;a href="#"&gt;a6&lt;/a&gt; &lt;/div&gt; &lt;script src="https://cdn.bootcss.com/jquery/3.3.0/jquery.js"&gt; &lt;/script&gt; &lt;script&gt; $('#div1').click(function () &#123; let fn = function () &#123; $(this).css('background-color', 'yellow') &#125; fn = $.proxy(fn, this) setTimeout(fn,1000) &#125;) &lt;/script&gt;&lt;/body&gt; 场景3 明星与经纪人 1234567891011121314151617181920212223242526272829303132333435// 明星let star = &#123; name: '张xx', age: 25, phone: 'star: 1390000011111'&#125;//经纪人let agent = new Proxy(star,&#123; get: function (target, key) &#123; if (key === 'phone')&#123; return 'agent: 16899997777' &#125; if (key === 'price') &#123; return 120000 &#125; return target[key] &#125;, set: function (target, key, val) &#123; if (key === 'customPrice')&#123; if (val &lt; 100000)&#123; throw new Error('价格太低') &#125;else &#123; target[key] = value return true &#125; &#125; &#125;&#125;)console.log(agent.name)console.log(agent.age)console.log(agent.phone)console.log(agent.price)agent.customPrice = 90000]]></content>
      <categories>
        <category>js中的设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰器模式]]></title>
    <url>%2F2018%2F06%2F27%2F%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[为对象添加新功能，不改变原有的结构和功能 相关代码实现1234567891011121314151617181920212223class Circle &#123; draw() &#123; console.log('画一个圆') &#125;&#125;class Decorator &#123; constructor(circle)&#123; this.circle = circle &#125; draw() &#123; this.circle.draw() this.setRedBorder(circle) &#125; setRedBorder(cicle)&#123; console.log('设置红色边框') &#125;&#125;let circle = new Circle()circle.draw()let decorator = new Decorator(circle)decorator.draw() 使用场景(es7装饰器)core-decorators第三库的使用 环境配置 1234567 npm install @babel/plugin-proposal-decorators --save-dev.babelrc相关配置 &#123; &quot;presets&quot;: [&quot;@babel/preset-env&quot;], &quot;plugins&quot;: [[&quot;@babel/plugin-proposal-decorators&quot;,&#123;&quot;legacy&quot;:true&#125;]] &#125; 场景1 123456789@testDecclass Demo &#123;&#125;function testDec (target) &#123; target.desc = true&#125;alert(Demo.desc) 场景2 1234567891011121314151617181920function mixin (...list) &#123; return function (target) &#123; Object.assign(target.prototype,...list) &#125;&#125;const Foo = &#123; foo()&#123; alert('foo') &#125;&#125;@mixin(Foo)class MyClass &#123;&#125;let tem = new MyClass()tem.foo() 场景3 123456789101112131415161718192021function readOnly (target,name,descriptor) &#123; descriptor.writable = false console.log(descriptor) return descriptor&#125;class Person &#123; constructor() &#123; this.first = 'A' this.last = 'B' &#125; @readOnly name() &#123; return `$&#123;this.first&#125; $&#123;this.last&#125;` &#125;&#125;let p = new Person()console.log(p.name())p.name = function () &#123; return '你好'&#125;console.log(p.name()) 场景4 12345678910111213141516function log (target, name, decriptor) &#123; let oldValue = decriptor.value decriptor.value = function () &#123; console.log(`calling $&#123;name&#125; width $&#123;arguments&#125;`) return oldValue.apply(this,arguments) &#125; return decriptor&#125;class Math &#123; @log add(a, b) &#123; return a + b &#125;&#125;let math = new Math()const result = math.add(2,4)]]></content>
      <categories>
        <category>js中的设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适配器模式]]></title>
    <url>%2F2018%2F06%2F25%2F%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[旧接口格式和使用者不兼容，中间加一个适配转换接口 相关代码实现1234567891011121314151617class Adaptee &#123; specificRequest() &#123; return '德国标准插头' &#125;&#125;class Target &#123; constructor() &#123; this.adaptee = new Adaptee() &#125; request() &#123; let info = this.adaptee.specificRequest() return `$&#123;info&#125; - 转化器 - 中国标准插头` &#125;&#125;let target = new Target()let res = target.request()console.log(res) 使用场景场景1 旧接口封装 1234567891011121314151617新封装的接口ajax(&#123; url: '/getData', type: 'Post', dataType: 'json', data: &#123; id: '123' &#125; &#125;).done(function() &#123;&#125;)但因为历史原因，代码中全部都是: $.ajax(&#123;...&#125;)可以做如下修改:做一层适配器let $ = &#123; ajax:function (options) &#123; return ajax(options); &#125;&#125;]]></content>
      <categories>
        <category>js中的设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合模式]]></title>
    <url>%2F2018%2F06%2F23%2F%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[生成树形结构，表示“整体-部分”关系，让整体和部分都具有一致的操作方式 相关代码实现12345678910111213141516171819&#123; tag: 'div', attr: &#123; id: 'div1', className: 'container' &#125;, children: [ &#123; tag: 'p', attr: &#123;&#125;, chirldren: ['123'] &#125;, &#123; tag: 'p', attr: &#123;&#125;, chirdren: ['456'] &#125; ] &#125;]]></content>
      <categories>
        <category>js中的设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2018%2F06%2F23%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[相关代码实现12345678910111213141516171819class SingleObject&#123; login() &#123; console.log('login...') &#125;&#125;SingleObject.getInstance = (function () &#123; let instance return function () &#123; if (!instance)&#123; instance = new SingleObject() &#125; return instance &#125;&#125;)()let obj1 = SingleObject.getInstance()obj1.login()let obj2 = SingleObject.getInstance()obj2.login()console.log('obj1 === obj2',obj1 === obj2) 场景1 模拟登录 123456789101112131415161718192021222324252627282930313233343536class LoginForm &#123; constructor() &#123; this.state = 'hide' &#125; show() &#123; if (this.state === 'show')&#123; alert('已显示') return &#125; this.state = 'show' console.log('登录框显示成功') &#125; hide() &#123; if (this.state === 'hide')&#123; alert('已隐藏') return &#125; this.state = 'hide' console.log('登录框已隐藏') &#125;&#125;LoginForm.getInstance = (function () &#123; let instance return function () &#123; if (!instance)&#123; instance = new LoginForm() &#125; return instance &#125;&#125;)()let login1 = LoginForm.getInstance()login1.show()let login2 = LoginForm.getInstance()login2.show()]]></content>
      <categories>
        <category>js中的设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式]]></title>
    <url>%2F2018%2F06%2F22%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[不同策略分开处理，避免出现if…else或者switch…case 使用策略模式前相关代码实现 1234567891011121314151617181920212223class User &#123; constructor (type) &#123; this.type = type &#125; buy() &#123; if (this.type === 'ordinary') &#123; console.log('普通用户购买') &#125;else if(this.type === 'member')&#123; console.log('会员用户购买') &#125;else if (this.type === 'vip')&#123; console.log('vip 用户购买') &#125; &#125;&#125;let u1 = new User('ordinary')u1.buy()let u2 = new User('member')u2.buy()let u3 = new User('vip')u3.buy() 使用策略模式之后相关代码实现 1234567891011121314151617181920212223242526class OrdinaryUser &#123; buy() &#123; console.log('普通用户购买') &#125;&#125;class MemberUser &#123; buy() &#123; console.log('会员用户购买') &#125;&#125;class VipUser &#123; buy() &#123; console.log('vip用户购买') &#125;&#125;let u1 = new OrdinaryUser()u1.buy()let u2 = new MemberUser()u2.buy()let u3 = new VipUser()u3.buy()]]></content>
      <categories>
        <category>js中的设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂模式]]></title>
    <url>%2F2018%2F06%2F22%2F%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[将new操作单独封装，遇到new时，就要考虑是否使用工厂模式 相关代码实现12345678910111213141516171819202122232425class Product &#123; constructor(name) &#123; this.name = name &#125; init() &#123; alert('init') &#125; fun1() &#123; alert('fun1') &#125; fun2() &#123; alert('fun2') &#125;&#125;class Creator &#123; create(name) &#123; return new Product(name) &#125;&#125;let creator = new Creator()let p = creator.create('p1')p.init()p.fun2()]]></content>
      <categories>
        <category>js中的设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo搭建Next主题使用小结]]></title>
    <url>%2F2018%2F06%2F21%2FHexoNext%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[自己在使用hexo搭建博客的时候碰到了不少坑，下面来做一些总结吧! 注: 在 Hexo 中有两份主要的配置文件，其名称都是 _config.yml。 其中，一份位于站点根目录下，主要包含 Hexo 本身的配置；另一份位于主题目录下，这份配置由主题作者提供，主要用于配置主题相关的选项。为了描述方便，在以下说明中，将前者称为 站点配置文件， 后者称为 主题配置文件。 1. 启动及部署指令本地查看效果12hexo generatehexo server 部署到服务器123hexo clean (必须要，不然有时因为缓存问题，服务器更新不了主题)hexo generatehexo d 2. next主题配置博客主题样式主题配置文件修改 scheme: Pisces 设置语言站点配置文件修改 language: zh-Hans 设置菜单栏主题配置文件修改 1234567menu: home: / || home tags: /tags/ || tags categories: /categories/ || th archives: /archives/ || archivemenu_icons: enable: true 设置菜单栏总是靠左显示主题配置文件修改 123sidebar: position: left display: always 设置头像主题配置文件修改 1avatar: http://example.com/avatar.png 设置作者昵称站点配置文件修改 author: xxx 设置首页只显示预览(卡片效果)主题配置文件修改 123auto_excerpt: enable: true length: 150 添加站点搜索功能第一步 站点根目录安装 hexo-generator-searchdb 1npm install hexo-generator-searchdb --save 第二步 站点配置文件 添加search字段具体如下 12345search: path: search.xml field: post format: html limit: 10000 第三步 主题配置文件 修改 12local_search: enable: true 添加标签页面第一步 在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 tags 12$ cd your-hexo-site$ hexo new page tags 第二步 .md的页面内容设置如下 123title: js设计模式date: 2014-12-22 12:39:04type: &quot;tags&quot;(必填) 第三步 修改菜单 在菜单中添加链接，编辑主题配置文件， 添加 tags 到 menu 中，如下: 1234menu: home: / archives: /archives tags: /tags (必填) 添加分类页面第一步 在终端窗口下，定位到 Hexo 站点目录下。使用 hexo new page 新建一个页面，命名为 categories 12cd your-hexo-sitehexo new page categories 第二步 编辑刚新建的页面，将页面的 type 设置为 categories ，主题将自动为这个页面显示分类。页面内容如下： 1234title: 分类date: 2014-12-22 12:39:04type: &quot;categories&quot; (必填)--- 第三步 在菜单中添加链接。编辑主题配置文件,添加 categories 到 menu 中，如下: 1234menu: home: / archives: /archives categories: /categories (必填)]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
